<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">Home</a></li><li class="chapter-item affix "><li class="part-title">src</li><li class="chapter-item "><a href="src/abstract/index.html">❱ abstract</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/abstract/DeployerDiscoverableMetaV1.sol/struct.DeployerDiscoverableMetaV1ConstructionConfig.html">DeployerDiscoverableMetaV1ConstructionConfig</a></li><li class="chapter-item "><a href="src/abstract/DeployerDiscoverableMetaV1.sol/abstract.DeployerDiscoverableMetaV1.html">DeployerDiscoverableMetaV1</a></li></ol></li><li class="chapter-item "><a href="src/concrete/index.html">❱ concrete</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedPointers.html">UnexpectedPointers</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedInterpreterBytecodeHash.html">UnexpectedInterpreterBytecodeHash</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.MissingEntrypoint.html">MissingEntrypoint</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedStoreBytecodeHash.html">UnexpectedStoreBytecodeHash</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedOpMetaHash.html">UnexpectedOpMetaHash</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.NegativeStackIndex.html">NegativeStackIndex</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/struct.RainterpreterExpressionDeployerConstructionConfig.html">RainterpreterExpressionDeployerConstructionConfig</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/contract.RainterpreterExpressionDeployerNP.html">RainterpreterExpressionDeployerNP</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/constants.RainterpreterExpressionDeployerNP.html">RainterpreterExpressionDeployerNP constants</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExtern.sol/error.BadInputs.html">BadInputs</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExtern.sol/error.UnknownOp.html">UnknownOp</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterExtern.sol/contract.RainterpreterExtern.html">RainterpreterExtern</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterNP.sol/error.NegativeStackLength.html">NegativeStackLength</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterNP.sol/contract.RainterpreterNP.html">RainterpreterNP</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterStore.sol/error.RainterpreterStoreOddSetLength.html">RainterpreterStoreOddSetLength</a></li><li class="chapter-item "><a href="src/concrete/RainterpreterStore.sol/contract.RainterpreterStore.html">RainterpreterStore</a></li></ol></li><li class="chapter-item "><a href="src/interface/index.html">❱ interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/interface/deprecated/index.html">❱ deprecated</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/interface/deprecated/IInterpreterCallerV1.sol/struct.SignedContext.html">SignedContext</a></li><li class="chapter-item "><a href="src/interface/deprecated/IInterpreterCallerV1.sol/interface.IInterpreterCallerV1.html">IInterpreterCallerV1</a></li><li class="chapter-item "><a href="src/interface/deprecated/IInterpreterCallerV1.sol/constants.IInterpreterCallerV1.html">IInterpreterCallerV1 constants</a></li></ol></li><li class="chapter-item "><a href="src/interface/unstable/index.html">❱ unstable</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/interface/unstable/IDebugExpressionDeployerV1.sol/interface.IDebugExpressionDeployerV1.html">IDebugExpressionDeployerV1</a></li><li class="chapter-item "><a href="src/interface/unstable/IDebugInterpreterV1.sol/interface.IDebugInterpreterV1.html">IDebugInterpreterV1</a></li><li class="chapter-item "><a href="src/interface/unstable/IExpressionDeployerV2.sol/interface.IExpressionDeployerV2.html">IExpressionDeployerV2</a></li><li class="chapter-item "><a href="src/interface/unstable/IExpressionDeployerV2.sol/constants.IExpressionDeployerV2.html">IExpressionDeployerV2 constants</a></li><li class="chapter-item "><a href="src/interface/unstable/IParserV1.sol/interface.IParserV1.html">IParserV1</a></li></ol></li><li class="chapter-item "><a href="src/interface/IExpressionDeployerV1.sol/interface.IExpressionDeployerV1.html">IExpressionDeployerV1</a></li><li class="chapter-item "><a href="src/interface/IExpressionDeployerV1.sol/constants.IExpressionDeployerV1.html">IExpressionDeployerV1 constants</a></li><li class="chapter-item "><a href="src/interface/IInterpreterCallerV2.sol/struct.SignedContextV1.html">SignedContextV1</a></li><li class="chapter-item "><a href="src/interface/IInterpreterCallerV2.sol/interface.IInterpreterCallerV2.html">IInterpreterCallerV2</a></li><li class="chapter-item "><a href="src/interface/IInterpreterCallerV2.sol/constants.IInterpreterCallerV2.html">IInterpreterCallerV2 constants</a></li><li class="chapter-item "><a href="src/interface/IInterpreterExternV1.sol/type.EncodedExternDispatch.html">EncodedExternDispatch</a></li><li class="chapter-item "><a href="src/interface/IInterpreterExternV1.sol/type.ExternDispatch.html">ExternDispatch</a></li><li class="chapter-item "><a href="src/interface/IInterpreterExternV1.sol/interface.IInterpreterExternV1.html">IInterpreterExternV1</a></li><li class="chapter-item "><a href="src/interface/IInterpreterStoreV1.sol/type.FullyQualifiedNamespace.html">FullyQualifiedNamespace</a></li><li class="chapter-item "><a href="src/interface/IInterpreterStoreV1.sol/interface.IInterpreterStoreV1.html">IInterpreterStoreV1</a></li><li class="chapter-item "><a href="src/interface/IInterpreterStoreV1.sol/constants.IInterpreterStoreV1.html">IInterpreterStoreV1 constants</a></li><li class="chapter-item "><a href="src/interface/IInterpreterV1.sol/type.SourceIndex.html">SourceIndex</a></li><li class="chapter-item "><a href="src/interface/IInterpreterV1.sol/type.EncodedDispatch.html">EncodedDispatch</a></li><li class="chapter-item "><a href="src/interface/IInterpreterV1.sol/type.StateNamespace.html">StateNamespace</a></li><li class="chapter-item "><a href="src/interface/IInterpreterV1.sol/type.Operand.html">Operand</a></li><li class="chapter-item "><a href="src/interface/IInterpreterV1.sol/interface.IInterpreterV1.html">IInterpreterV1</a></li><li class="chapter-item "><a href="src/interface/IInterpreterV1.sol/constants.IInterpreterV1.html">IInterpreterV1 constants</a></li></ol></li><li class="chapter-item "><a href="src/lib/index.html">❱ lib</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/caller/index.html">❱ caller</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/caller/LibContext.sol/error.InvalidSignature.html">InvalidSignature</a></li><li class="chapter-item "><a href="src/lib/caller/LibContext.sol/library.LibContext.html">LibContext</a></li><li class="chapter-item "><a href="src/lib/caller/LibDeployerDiscoverable.sol/library.LibDeployerDiscoverable.html">LibDeployerDiscoverable</a></li><li class="chapter-item "><a href="src/lib/caller/LibEncodedDispatch.sol/library.LibEncodedDispatch.html">LibEncodedDispatch</a></li><li class="chapter-item "><a href="src/lib/caller/LibEvaluable.sol/struct.EvaluableConfig.html">EvaluableConfig</a></li><li class="chapter-item "><a href="src/lib/caller/LibEvaluable.sol/struct.Evaluable.html">Evaluable</a></li><li class="chapter-item "><a href="src/lib/caller/LibEvaluable.sol/library.LibEvaluable.html">LibEvaluable</a></li></ol></li><li class="chapter-item "><a href="src/lib/compile/index.html">❱ compile</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/compile/LibCompile.sol/library.LibCompile.html">LibCompile</a></li></ol></li><li class="chapter-item "><a href="src/lib/eval/index.html">❱ eval</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/eval/LibEval.sol/library.LibEval.html">LibEval</a></li></ol></li><li class="chapter-item "><a href="src/lib/extern/index.html">❱ extern</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/extern/LibExtern.sol/library.LibExtern.html">LibExtern</a></li></ol></li><li class="chapter-item "><a href="src/lib/integrity/index.html">❱ integrity</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/integrity/LibIntegrityCheck.sol/error.MinStackBottom.html">MinStackBottom</a></li><li class="chapter-item "><a href="src/lib/integrity/LibIntegrityCheck.sol/error.StackPopUnderflow.html">StackPopUnderflow</a></li><li class="chapter-item "><a href="src/lib/integrity/LibIntegrityCheck.sol/error.MinFinalStack.html">MinFinalStack</a></li><li class="chapter-item "><a href="src/lib/integrity/LibIntegrityCheck.sol/struct.IntegrityCheckState.html">IntegrityCheckState</a></li><li class="chapter-item "><a href="src/lib/integrity/LibIntegrityCheck.sol/library.LibIntegrityCheck.html">LibIntegrityCheck</a></li><li class="chapter-item "><a href="src/lib/integrity/LibIntegrityCheck.sol/constants.LibIntegrityCheck.html">LibIntegrityCheck constants</a></li></ol></li><li class="chapter-item "><a href="src/lib/ns/index.html">❱ ns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/ns/LibNamespace.sol/library.LibNamespace.html">LibNamespace</a></li></ol></li><li class="chapter-item "><a href="src/lib/op/index.html">❱ op</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/op/chainlink/index.html">❱ chainlink</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/op/chainlink/LibOpChainlinkOraclePrice.sol/library.LibOpChainlinkOraclePrice.html">LibOpChainlinkOraclePrice</a></li></ol></li><li class="chapter-item "><a href="src/lib/op/evm/index.html">❱ evm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/op/evm/LibOpChainId.sol/library.LibOpChainId.html">LibOpChainId</a></li></ol></li><li class="chapter-item "><a href="src/lib/op/LibAllStandardOpsNP.sol/error.BadDynamicLength.html">BadDynamicLength</a></li><li class="chapter-item "><a href="src/lib/op/LibAllStandardOpsNP.sol/library.LibAllStandardOpsNP.html">LibAllStandardOpsNP</a></li><li class="chapter-item "><a href="src/lib/op/LibAllStandardOpsNP.sol/constants.LibAllStandardOpsNP.html">LibAllStandardOpsNP constants</a></li><li class="chapter-item "><a href="src/lib/op/LibOp.sol/error.UnexpectedResultLength.html">UnexpectedResultLength</a></li><li class="chapter-item "><a href="src/lib/op/LibOp.sol/library.LibOp.html">LibOp</a></li></ol></li><li class="chapter-item "><a href="src/lib/parse/index.html">❱ parse</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/parse/LibCtPop.sol/library.LibCtPop.html">LibCtPop</a></li><li class="chapter-item "><a href="src/lib/parse/LibCtPop.sol/constants.LibCtPop.html">LibCtPop constants</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.MissingFinalSemi.html">MissingFinalSemi</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.UnexpectedLHSChar.html">UnexpectedLHSChar</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.UnexpectedRHSChar.html">UnexpectedRHSChar</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.UnexpectedRightParen.html">UnexpectedRightParen</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.WordSize.html">WordSize</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.UnknownWord.html">UnknownWord</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.MaxSources.html">MaxSources</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.DanglingSource.html">DanglingSource</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/error.StackOverflow.html">StackOverflow</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/struct.ParseState.html">ParseState</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/library.LibParseState.html">LibParseState</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/library.LibParse.html">LibParse</a></li><li class="chapter-item "><a href="src/lib/parse/LibParse.sol/constants.LibParse.html">LibParse constants</a></li><li class="chapter-item "><a href="src/lib/parse/LibParseMeta.sol/error.DuplicateFingerprint.html">DuplicateFingerprint</a></li><li class="chapter-item "><a href="src/lib/parse/LibParseMeta.sol/library.LibParseMeta.html">LibParseMeta</a></li><li class="chapter-item "><a href="src/lib/parse/LibParseMeta.sol/constants.LibParseMeta.html">LibParseMeta constants</a></li></ol></li><li class="chapter-item "><a href="src/lib/state/index.html">❱ state</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/state/LibInterpreterState.sol/struct.InterpreterState.html">InterpreterState</a></li><li class="chapter-item "><a href="src/lib/state/LibInterpreterState.sol/library.LibInterpreterState.html">LibInterpreterState</a></li><li class="chapter-item "><a href="src/lib/state/LibInterpreterStateDataContract.sol/library.LibInterpreterStateDataContract.html">LibInterpreterStateDataContract</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rainprotocol/rain.interpreter" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="raininterpreter"><a class="header" href="#raininterpreter">rain.interpreter</a></h1>
<p>Docs at https://rainprotocol.github.io/rain.interpreter</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Standard libraries and interfaces defining and working with <code>InterpeterState</code> including:</p>
<ul>
<li>the standard <code>eval</code> loop</li>
<li>source compilation from opcodes</li>
<li>state (de)serialization (more gas efficient than abi encoding)</li>
</ul>
<p>Interpreters are designed to be highly moddable behind the <code>IInterpreterV1</code>
interface, but pretty much any interpreter that uses <code>InterpreterState</code> will
need these low level facilities verbatim. Further, these facilities
(with possible exception of debugging logic), while relatively short in terms
of lines of code, are surprisingly fragile to maintain in a gas efficient way
so we don't recommend reinventing this wheel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="src/abstract/DeployerDiscoverableMetaV1.sol/struct.DeployerDiscoverableMetaV1ConstructionConfig.html">DeployerDiscoverableMetaV1ConstructionConfig</a></li>
<li><a href="src/abstract/DeployerDiscoverableMetaV1.sol/abstract.DeployerDiscoverableMetaV1.html">DeployerDiscoverableMetaV1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployerdiscoverablemetav1constructionconfig"><a class="header" href="#deployerdiscoverablemetav1constructionconfig">DeployerDiscoverableMetaV1ConstructionConfig</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/abstract/DeployerDiscoverableMetaV1.sol">Git Source</a></p>
<p>Construction config for <code>DeployerDiscoverableMetaV1</code>.</p>
<pre><code class="language-solidity">struct DeployerDiscoverableMetaV1ConstructionConfig {
    address deployer;
    bytes meta;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployerdiscoverablemetav1"><a class="header" href="#deployerdiscoverablemetav1">DeployerDiscoverableMetaV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/abstract/DeployerDiscoverableMetaV1.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
IMetaV1</p>
<p>Upon construction, checks metadata against a known hash, emits it
then touches the deployer (deploy an empty expression). This allows indexers
to discover the metadata of the <code>DeployerDiscoverableMetaV1</code> contract by
indexing the deployer. In this way the deployer acts as a pseudo-registry by
virtue of it being a natural hub for interactions with calling contracts.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="constructor"><a class="header" href="#constructor">constructor</a></h3>
<pre><code class="language-solidity">constructor(bytes32 metaHash, DeployerDiscoverableMetaV1ConstructionConfig memory config);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-1"><a class="header" href="#contents-1">Contents</a></h1>
<ul>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedPointers.html">UnexpectedPointers</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedInterpreterBytecodeHash.html">UnexpectedInterpreterBytecodeHash</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.MissingEntrypoint.html">MissingEntrypoint</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedStoreBytecodeHash.html">UnexpectedStoreBytecodeHash</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.UnexpectedOpMetaHash.html">UnexpectedOpMetaHash</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/error.NegativeStackIndex.html">NegativeStackIndex</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/struct.RainterpreterExpressionDeployerConstructionConfig.html">RainterpreterExpressionDeployerConstructionConfig</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/contract.RainterpreterExpressionDeployerNP.html">RainterpreterExpressionDeployerNP</a></li>
<li><a href="src/concrete/RainterpreterExpressionDeployerNP.sol/constants.RainterpreterExpressionDeployerNP.html">RainterpreterExpressionDeployerNP constants</a></li>
<li><a href="src/concrete/RainterpreterExtern.sol/error.BadInputs.html">BadInputs</a></li>
<li><a href="src/concrete/RainterpreterExtern.sol/error.UnknownOp.html">UnknownOp</a></li>
<li><a href="src/concrete/RainterpreterExtern.sol/contract.RainterpreterExtern.html">RainterpreterExtern</a></li>
<li><a href="src/concrete/RainterpreterNP.sol/error.NegativeStackLength.html">NegativeStackLength</a></li>
<li><a href="src/concrete/RainterpreterNP.sol/contract.RainterpreterNP.html">RainterpreterNP</a></li>
<li><a href="src/concrete/RainterpreterStore.sol/error.RainterpreterStoreOddSetLength.html">RainterpreterStoreOddSetLength</a></li>
<li><a href="src/concrete/RainterpreterStore.sol/contract.RainterpreterStore.html">RainterpreterStore</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedpointers"><a class="header" href="#unexpectedpointers">UnexpectedPointers</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p><em>Thrown when the pointers known to the expression deployer DO NOT match
the interpreter it is constructed for. This WILL cause undefined expression
behaviour so MUST REVERT.</em></p>
<pre><code class="language-solidity">error UnexpectedPointers(bytes actualPointers);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedinterpreterbytecodehash"><a class="header" href="#unexpectedinterpreterbytecodehash">UnexpectedInterpreterBytecodeHash</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p>Thrown when the <code>RainterpreterExpressionDeployer</code> is constructed with unknown
interpreter bytecode.</p>
<pre><code class="language-solidity">error UnexpectedInterpreterBytecodeHash(bytes32 actualBytecodeHash);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="missingentrypoint"><a class="header" href="#missingentrypoint">MissingEntrypoint</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p><em>There are more entrypoints defined by the minimum stack outputs than
there are provided sources. This means the calling contract WILL attempt to
eval a dangling reference to a non-existent source at some point, so this
MUST REVERT.</em></p>
<pre><code class="language-solidity">error MissingEntrypoint(uint256 expectedEntrypoints, uint256 actualEntrypoints);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedstorebytecodehash"><a class="header" href="#unexpectedstorebytecodehash">UnexpectedStoreBytecodeHash</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p>Thrown when the <code>Rainterpreter</code> is constructed with unknown store bytecode.</p>
<pre><code class="language-solidity">error UnexpectedStoreBytecodeHash(bytes32 actualBytecodeHash);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedopmetahash"><a class="header" href="#unexpectedopmetahash">UnexpectedOpMetaHash</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p>Thrown when the <code>Rainterpreter</code> is constructed with unknown opMeta.</p>
<pre><code class="language-solidity">error UnexpectedOpMetaHash(bytes32 actualOpMeta);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="negativestackindex"><a class="header" href="#negativestackindex">NegativeStackIndex</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p>Thrown when the integrity check returns a negative stack index.</p>
<pre><code class="language-solidity">error NegativeStackIndex(int256 index);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rainterpreterexpressiondeployerconstructionconfig"><a class="header" href="#rainterpreterexpressiondeployerconstructionconfig">RainterpreterExpressionDeployerConstructionConfig</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p>All config required to construct a <code>Rainterpreter</code>.</p>
<pre><code class="language-solidity">struct RainterpreterExpressionDeployerConstructionConfig {
    address interpreter;
    address store;
    bytes meta;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rainterpreterexpressiondeployernp"><a class="header" href="#rainterpreterexpressiondeployernp">RainterpreterExpressionDeployerNP</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/concrete/RainterpreterExpressionDeployerNP.sol//src/interface/unstable/IExpressionDeployerV2.sol/interface.IExpressionDeployerV2.html">IExpressionDeployerV2</a>, <a href="src/concrete/RainterpreterExpressionDeployerNP.sol//src/interface/unstable/IDebugExpressionDeployerV1.sol/interface.IDebugExpressionDeployerV1.html">IDebugExpressionDeployerV1</a>, <a href="src/concrete/RainterpreterExpressionDeployerNP.sol//src/interface/unstable/IParserV1.sol/interface.IParserV1.html">IParserV1</a>, ERC165</p>
<p>!!!EXPERIMENTAL!!! This is the deployer for the RainterpreterNP
interpreter. Notably includes onchain parsing/compiling of expressions from
Rainlang strings.</p>
<h2 id="state-variables"><a class="header" href="#state-variables">State Variables</a></h2>
<h3 id="iinterpreter"><a class="header" href="#iinterpreter">iInterpreter</a></h3>
<p>The interpreter with known bytecode that this deployer is constructed
for.</p>
<pre><code class="language-solidity">IInterpreterV1 public immutable iInterpreter;
</code></pre>
<h3 id="istore"><a class="header" href="#istore">iStore</a></h3>
<p>The store with known bytecode that this deployer is constructed for.</p>
<pre><code class="language-solidity">IInterpreterStoreV1 public immutable iStore;
</code></pre>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h3 id="constructor-1"><a class="header" href="#constructor-1">constructor</a></h3>
<pre><code class="language-solidity">constructor(RainterpreterExpressionDeployerConstructionConfig memory config);
</code></pre>
<h3 id="supportsinterface"><a class="header" href="#supportsinterface">supportsInterface</a></h3>
<p>THIS IS NOT A SECURITY CHECK. IT IS AN INTEGRITY CHECK TO PREVENT
HONEST MISTAKES.
THIS IS NOT A SECURITY CHECK. IT IS AN INTEGRITY CHECK TO PREVENT
HONEST MISTAKES.
This IS a security check. This prevents someone making an exact
bytecode copy of the interpreter and shipping different meta for
the copy to lie about what each op does in the interpreter.</p>
<pre><code class="language-solidity">function supportsInterface(bytes4 interfaceId_) public view virtual override returns (bool);
</code></pre>
<h3 id="offchaindebugeval"><a class="header" href="#offchaindebugeval">offchainDebugEval</a></h3>
<pre><code class="language-solidity">function offchainDebugEval(
    bytes[] memory sources,
    uint256[] memory constants,
    FullyQualifiedNamespace namespace,
    uint256[][] memory context,
    SourceIndex sourceIndex,
    uint256[] memory initialStack,
    uint8 minOutputs
) external view returns (uint256[] memory, uint256[] memory);
</code></pre>
<h3 id="parse"><a class="header" href="#parse">parse</a></h3>
<pre><code class="language-solidity">function parse(bytes memory data) external pure returns (bytes[] memory, uint256[] memory);
</code></pre>
<h3 id="deployexpression"><a class="header" href="#deployexpression">deployExpression</a></h3>
<p>Expressions are expected to be deployed onchain as immutable contract
code with a first class address like any other contract or account.
Technically this is optional in the sense that all the tools required to
eval some expression and define all its opcodes are available as
libraries.
In practise there are enough advantages to deploying the sources directly
onchain as contract data and loading them from the interpreter at eval:</p>
<ul>
<li>Loading and storing binary data is gas efficient as immutable contract
data</li>
<li>Expressions need to be immutable between their deploy time integrity
check and runtime evaluation</li>
<li>Passing the address of an expression through calldata to an interpreter
is cheaper than passing an entire expression through calldata</li>
<li>Conceptually a very simple approach, even if implementations like
SSTORE2 are subtle under the hood
The expression deployer MUST perform an integrity check of the source
code before it puts the expression onchain at a known address. The
integrity check MUST at a minimum (it is free to do additional static
analysis) calculate the memory required to be allocated for the stack in
total, and that no out of bounds memory reads/writes occur within this
stack. A simple example of an invalid source would be one that pushes one
value to the stack then attempts to pops two values, clearly we cannot
remove more values than we added. The <code>IExpressionDeployerV2</code> MUST revert
in the case of any integrity failure, all integrity checks MUST pass in
order for the deployment to complete.
Once the integrity check is complete the <code>IExpressionDeployerV2</code> MUST do
any additional processing required by its paired interpreter.
For example, the <code>IExpressionDeployerV2</code> MAY NEED to replace the indexed
opcodes in the <code>ExpressionConfig</code> sources with real function pointers
from the corresponding interpreter.</li>
</ul>
<pre><code class="language-solidity">function deployExpression(bytes[] memory sources, uint256[] memory constants, uint8[] memory minOutputs)
    external
    returns (IInterpreterV1, IInterpreterStoreV1, address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sources</code></td><td><code>bytes[]</code></td><td>Sources verbatim. These sources MUST be provided in their sequential/index opcode form as the deployment process will need to index into BOTH the integrity check and the final runtime function pointers. This will be emitted in an event for offchain processing to use the indexed opcode sources. The first N sources are considered entrypoints and will be integrity checked by the expression deployer against a starting stack height of 0. Non-entrypoint sources MAY be provided for internal use such as the <code>call</code> opcode but will NOT be integrity checked UNLESS entered by an opcode in an entrypoint.</td></tr>
<tr><td><code>constants</code></td><td><code>uint256[]</code></td><td>Constants verbatim. Constants are provided alongside sources rather than inline as it allows us to avoid variable length opcodes and can be more memory efficient if the same constant is referenced several times from the sources.</td></tr>
<tr><td><code>minOutputs</code></td><td><code>uint8[]</code></td><td>The first N sources on the state config are entrypoints to the expression where N is the length of the <code>minOutputs</code> array. Each item in the <code>minOutputs</code> array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>IInterpreterV1</code></td><td>interpreter The interpreter the deployer believes it is qualified to perform integrity checks on behalf of.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>IInterpreterStoreV1</code></td><td>store The interpreter store the deployer believes is compatible with the interpreter.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>expression The address of the deployed onchain expression. MUST be valid according to all integrity checks the deployer is aware of.</td></tr>
</tbody></table>
</div>
<h3 id="integritycheck"><a class="header" href="#integritycheck">integrityCheck</a></h3>
<p>Drives an integrity check of the provided sources and constants. This</p>
<pre><code class="language-solidity">function integrityCheck(bytes[] memory sources, uint256[] memory constants, uint8[] memory minOutputs)
    internal
    view
    returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sources</code></td><td><code>bytes[]</code></td><td>The sources to check.</td></tr>
<tr><td><code>constants</code></td><td><code>uint256[]</code></td><td>The constants to check.</td></tr>
<tr><td><code>minOutputs</code></td><td><code>uint8[]</code></td><td>The minimum number of outputs expected from each of the sources. Only applies to sources that are entrypoints. Internal sources have their integrity checked implicitly by the use of opcodes such as <code>call</code> that have min/max outputs in their operand.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The total stack size required to fully evaluate the expression. This is used to allocate the stack when deserializing the expression later so MUST be correct for ALL internal states of the evaluation. It is NOT sufficient to just return the final stack size as the stack grows and shrinks during evaluation.</td></tr>
</tbody></table>
</div>
<h3 id="integrityfunctionpointers"><a class="header" href="#integrityfunctionpointers">integrityFunctionPointers</a></h3>
<p>Defines all the function pointers to integrity checks. This is the
expression deployer's equivalent of the opcode function pointers and
follows a near identical dispatch process. These are never compiled into
source and are instead indexed into directly by the integrity check. The
indexing into integrity pointers (which has an out of bounds check) is a
proxy for enforcing that all opcode pointers exist at runtime, so the
length of the integrity pointers MUST match the length of opcode function
pointers. This function is <code>virtual</code> so that it can be overridden
pairwise with overrides to <code>functionPointers</code> on <code>Rainterpreter</code>.</p>
<pre><code class="language-solidity">function integrityFunctionPointers()
    internal
    view
    virtual
    returns (function(IntegrityCheckState memory, Operand, Pointer) view returns (Pointer)[] memory);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (IntegrityCheckState memory, Operand, Pointer) view returns (Pointer)[]</code></td><td>The list of integrity function pointers.</td></tr>
</tbody></table>
</div>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<h3 id="newexpression"><a class="header" href="#newexpression">NewExpression</a></h3>
<p>The config of the deployed expression including uncompiled sources. Will
only be emitted after the config passes the integrity check.</p>
<pre><code class="language-solidity">event NewExpression(address sender, bytes[] sources, uint256[] constants, uint8[] minOutputs);
</code></pre>
<h3 id="expressionaddress"><a class="header" href="#expressionaddress">ExpressionAddress</a></h3>
<p>The address of the deployed expression. Will only be emitted once the
expression can be loaded and deserialized into an evaluable interpreter
state.</p>
<pre><code class="language-solidity">event ExpressionAddress(address sender, address expression);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExpressionDeployerNP.sol">Git Source</a></p>
<h3 id="opcode_function_pointers"><a class="header" href="#opcode_function_pointers">OPCODE_FUNCTION_POINTERS</a></h3>
<p><em>The function pointers known to the expression deployer. These are
immutable for any given interpreter so once the expression deployer is
constructed and has verified that this matches what the interpreter reports,
it can use this constant value to compile and serialize expressions.</em></p>
<pre><code class="language-solidity">bytes constant OPCODE_FUNCTION_POINTERS = hex&quot;0afa&quot;;
</code></pre>
<h3 id="interpreter_bytecode_hash"><a class="header" href="#interpreter_bytecode_hash">INTERPRETER_BYTECODE_HASH</a></h3>
<p><em>Hash of the known interpreter bytecode.</em></p>
<pre><code class="language-solidity">bytes32 constant INTERPRETER_BYTECODE_HASH = bytes32(0xdfbbdaf24b08f29aef5b5dc337e7f3342da8225b8a830d0d7d5b5d0467507f2b);
</code></pre>
<h3 id="store_bytecode_hash"><a class="header" href="#store_bytecode_hash">STORE_BYTECODE_HASH</a></h3>
<p><em>Hash of the known store bytecode.</em></p>
<pre><code class="language-solidity">bytes32 constant STORE_BYTECODE_HASH = bytes32(0xd6130168250d3957ae34f8026c2bdbd7e21d35bb202e8540a9b3abcbc232ddb6);
</code></pre>
<h3 id="op_meta_hash"><a class="header" href="#op_meta_hash">OP_META_HASH</a></h3>
<p><em>Hash of the known op meta.</em></p>
<pre><code class="language-solidity">bytes32 constant OP_META_HASH = bytes32(0x2cf73adad61aae49cfe0a38448ca982e30a16b18fe56c294e51104f9148d94da);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="badinputs"><a class="header" href="#badinputs">BadInputs</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExtern.sol">Git Source</a></p>
<p>Thrown when the inputs don't match the expected inputs.</p>
<pre><code class="language-solidity">error BadInputs(uint256 expected, uint256 actual);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unknownop"><a class="header" href="#unknownop">UnknownOp</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExtern.sol">Git Source</a></p>
<p>Thrown when the opcode is not known.</p>
<pre><code class="language-solidity">error UnknownOp(uint256 opcode);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rainterpreterextern"><a class="header" href="#rainterpreterextern">RainterpreterExtern</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterExtern.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/concrete/RainterpreterExtern.sol//src/interface/IInterpreterExternV1.sol/interface.IInterpreterExternV1.html">IInterpreterExternV1</a>, ERC165</p>
<p>EXPERIMENTAL implementation of <code>IInterpreterExternV1</code>.
Currently only implements the Chainlink oracle price opcode as a starting
point to test and flesh out externs generally.
Hopefully one day the idea of there being only a single extern contract seems
quaint.</p>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<h3 id="supportsinterface-1"><a class="header" href="#supportsinterface-1">supportsInterface</a></h3>
<pre><code class="language-solidity">function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool);
</code></pre>
<h3 id="extern"><a class="header" href="#extern">extern</a></h3>
<p>Handles a single dispatch.</p>
<pre><code class="language-solidity">function extern(ExternDispatch dispatch, uint256[] memory inputs) external view returns (uint256[] memory outputs);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>dispatch</code></td><td><code>ExternDispatch</code></td><td>Encoded information about the extern to dispatch. Analogous to the opcode/operand in the interpreter.</td></tr>
<tr><td><code>inputs</code></td><td><code>uint256[]</code></td><td>The array of inputs for the dispatched logic.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>outputs</code></td><td><code>uint256[]</code></td><td>The result of the dispatched logic.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="negativestacklength"><a class="header" href="#negativestacklength">NegativeStackLength</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterNP.sol">Git Source</a></p>
<p>Thrown when the stack length is negative during eval.</p>
<pre><code class="language-solidity">error NegativeStackLength(int256 length);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rainterpreternp"><a class="header" href="#rainterpreternp">RainterpreterNP</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterNP.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/concrete/RainterpreterNP.sol//src/interface/IInterpreterV1.sol/interface.IInterpreterV1.html">IInterpreterV1</a>, <a href="src/concrete/RainterpreterNP.sol//src/interface/unstable/IDebugInterpreterV1.sol/interface.IDebugInterpreterV1.html">IDebugInterpreterV1</a>, ERC165</p>
<p>!!EXPERIMENTAL!! implementation of a Rainlang interpreter that is
compatible with native onchain Rainlang parsing. Initially copied verbatim
from the JS compatible Rainterpreter. This interpreter is deliberately
separate from the JS Rainterpreter to allow for experimentation with the
onchain interpreter without affecting the JS interpreter, up to and including
a complely different execution model and opcodes.</p>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<h3 id="supportsinterface-2"><a class="header" href="#supportsinterface-2">supportsInterface</a></h3>
<pre><code class="language-solidity">function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool);
</code></pre>
<h3 id="offchaindebugeval-1"><a class="header" href="#offchaindebugeval-1">offchainDebugEval</a></h3>
<pre><code class="language-solidity">function offchainDebugEval(
    IInterpreterStoreV1 store,
    FullyQualifiedNamespace namespace,
    bytes[] memory compiledSources,
    uint256[] memory constants,
    uint256[][] memory context,
    uint256[] memory stack,
    SourceIndex sourceIndex
) external view returns (uint256[] memory, uint256[] memory);
</code></pre>
<h3 id="eval"><a class="header" href="#eval">eval</a></h3>
<p>The raison d'etre for an interpreter. Given some expression and per-call
additional contextual data, produce a stack of results and a set of state
changes that the caller MAY OPTIONALLY pass back to be persisted by a
call to <code>IInterpreterStoreV1.set</code>.</p>
<pre><code class="language-solidity">function eval(IInterpreterStoreV1 store, StateNamespace namespace, EncodedDispatch dispatch, uint256[][] memory context)
    external
    view
    returns (uint256[] memory, uint256[] memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>store</code></td><td><code>IInterpreterStoreV1</code></td><td>The storage contract that the returned key/value pairs MUST be passed to IF the calling contract is in a non-static calling context. Static calling contexts MUST pass <code>address(0)</code>.</td></tr>
<tr><td><code>namespace</code></td><td><code>StateNamespace</code></td><td>The state namespace that will be fully qualified by the interpreter at runtime in order to perform gets on the underlying store. MUST be the same namespace passed to the store by the calling contract when sending the resulting key/value items to storage.</td></tr>
<tr><td><code>dispatch</code></td><td><code>EncodedDispatch</code></td><td>All the information required for the interpreter to load an expression, select an entrypoint and return the values expected by the caller. The interpreter MAY encode dispatches differently to <code>LibEncodedDispatch</code> but this WILL negatively impact compatibility for calling contracts that hardcode the encoding logic.</td></tr>
<tr><td><code>context</code></td><td><code>uint256[][]</code></td><td>A 2-dimensional array of data that can be indexed into at runtime by the interpreter. The calling contract is responsible for ensuring the authenticity and completeness of context data. The interpreter MUST revert at runtime if an expression attempts to index into some context value that is not provided by the caller. This implies that context reads cannot be checked for out of bounds reads at deploy time, as the runtime context MAY be provided in a different shape to what the expression is expecting. Same as <code>eval</code> but allowing the caller to specify a namespace under which the state changes will be applied. The interpeter MUST ensure that keys will never collide across namespaces, even if, for example: - The calling contract is malicious and attempts to craft a collision with state changes from another contract - The expression is malicious and attempts to craft a collision with other expressions evaluated by the same calling contract A malicious entity MAY have access to significant offchain resources to attempt to precompute key collisions through brute force. The collision resistance of namespaces should be comparable or equivalent to the collision resistance of the hashing algorithms employed by the blockchain itself, such as the design of <code>mapping</code> in Solidity that hashes each nested key to produce a collision resistant compound key.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256[]</code></td><td>stack The list of values produced by evaluating the expression. MUST NOT be longer than the maximum length specified by <code>dispatch</code>, if applicable.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256[]</code></td><td>kvs A list of pairwise key/value items to be saved in the store.</td></tr>
</tbody></table>
</div>
<h3 id="functionpointers"><a class="header" href="#functionpointers">functionPointers</a></h3>
<p>Exposes the function pointers as <code>uint16</code> values packed into a single
<code>bytes</code> in the same order as they would be indexed into by opcodes. For
example, if opcode <code>2</code> should dispatch function at position <code>0x1234</code> then
the start of the returned bytes would be <code>0xXXXXXXXX1234</code> where <code>X</code> is
a placeholder for the function pointers of opcodes <code>0</code> and <code>1</code>.
<code>IExpressionDeployerV1</code> contracts use these function pointers to
&quot;compile&quot; the expression into something that an interpreter can dispatch
directly without paying gas to lookup the same at runtime. As the
validity of any integrity check and subsequent dispatch is highly
sensitive to both the function pointers and overall bytecode of the
interpreter, <code>IExpressionDeployerV1</code> contracts SHOULD implement guards
against accidentally being deployed onchain paired against an unknown
interpreter. It is very easy for an apparent compatible pairing to be
subtly and critically incompatible due to addition/removal/reordering of
opcodes and compiler optimisations on the interpreter bytecode.
This MAY return different values during construction vs. all other times
after the interpreter has been successfully deployed onchain. DO NOT rely
on function pointers reported during contract construction.</p>
<pre><code class="language-solidity">function functionPointers() external view virtual returns (bytes memory);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rainterpreterstoreoddsetlength"><a class="header" href="#rainterpreterstoreoddsetlength">RainterpreterStoreOddSetLength</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterStore.sol">Git Source</a></p>
<p>Thrown when a <code>set</code> call is made with an odd number of arguments.</p>
<pre><code class="language-solidity">error RainterpreterStoreOddSetLength(uint256 length);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rainterpreterstore"><a class="header" href="#rainterpreterstore">RainterpreterStore</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/concrete/RainterpreterStore.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/concrete/RainterpreterStore.sol//src/interface/IInterpreterStoreV1.sol/interface.IInterpreterStoreV1.html">IInterpreterStoreV1</a>, ERC165</p>
<p>Simplest possible <code>IInterpreterStoreV1</code> that could work.
Takes key/value pairings from the input array and stores each in an internal
mapping. <code>StateNamespace</code> is fully qualified only by <code>msg.sender</code> on set and
doesn't attempt to do any deduping etc. if the same key appears twice it will
be set twice.</p>
<h2 id="state-variables-1"><a class="header" href="#state-variables-1">State Variables</a></h2>
<h3 id="sstore"><a class="header" href="#sstore">sStore</a></h3>
<p>Store is several tiers of sandbox.
0. Address hashed into <code>FullyQualifiedNamespace</code> is <code>msg.sender</code> so that
callers cannot attack each other</p>
<ol>
<li>StateNamespace is caller-provided namespace so that expressions cannot
attack each other</li>
<li><code>uint256</code> is expression-provided key</li>
<li><code>uint256</code> is expression-provided value
tiers 0 and 1 are both embodied in the <code>FullyQualifiedNamespace</code>.</li>
</ol>
<pre><code class="language-solidity">mapping(FullyQualifiedNamespace =&gt; mapping(uint256 =&gt; uint256)) internal sStore;
</code></pre>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<h3 id="supportsinterface-3"><a class="header" href="#supportsinterface-3">supportsInterface</a></h3>
<pre><code class="language-solidity">function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool);
</code></pre>
<h3 id="set"><a class="header" href="#set">set</a></h3>
<p>Mutates the interpreter store in bulk. The bulk values are provided in
the form of a <code>uint256[]</code> which can be treated e.g. as pairwise keys and
values to be stored in a Solidity mapping. The <code>IInterpreterStoreV1</code>
defines the meaning of the <code>uint256[]</code> for its own storage logic.</p>
<pre><code class="language-solidity">function set(StateNamespace namespace, uint256[] calldata kvs) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>namespace</code></td><td><code>StateNamespace</code></td><td>The unqualified namespace for the set that MUST be fully qualified by the <code>IInterpreterStoreV1</code> to prevent key collisions between callers. The fully qualified namespace forms a compound key with the keys for each value to set.</td></tr>
<tr><td><code>kvs</code></td><td><code>uint256[]</code></td><td>The list of changes to apply to the store's internal state.</td></tr>
</tbody></table>
</div>
<h3 id="get"><a class="header" href="#get">get</a></h3>
<p>This would be picked up by an out of bounds index below, but it's
nice to have a more specific error message.</p>
<pre><code class="language-solidity">function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>namespace</code></td><td><code>FullyQualifiedNamespace</code></td><td>The fully qualified namespace to get a single value for.</td></tr>
<tr><td><code>key</code></td><td><code>uint256</code></td><td>The key to get the value for within the namespace.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The value OR ZERO IF NOT SET.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-2"><a class="header" href="#contents-2">Contents</a></h1>
<ul>
<li><a href="src/interface//src/interface/deprecated">deprecated</a></li>
<li><a href="src/interface//src/interface/unstable">unstable</a></li>
<li><a href="src/interface/IExpressionDeployerV1.sol/interface.IExpressionDeployerV1.html">IExpressionDeployerV1</a></li>
<li><a href="src/interface/IExpressionDeployerV1.sol/constants.IExpressionDeployerV1.html">IExpressionDeployerV1 constants</a></li>
<li><a href="src/interface/IInterpreterCallerV2.sol/struct.SignedContextV1.html">SignedContextV1</a></li>
<li><a href="src/interface/IInterpreterCallerV2.sol/interface.IInterpreterCallerV2.html">IInterpreterCallerV2</a></li>
<li><a href="src/interface/IInterpreterCallerV2.sol/constants.IInterpreterCallerV2.html">IInterpreterCallerV2 constants</a></li>
<li><a href="src/interface/IInterpreterExternV1.sol/type.EncodedExternDispatch.html">EncodedExternDispatch</a></li>
<li><a href="src/interface/IInterpreterExternV1.sol/type.ExternDispatch.html">ExternDispatch</a></li>
<li><a href="src/interface/IInterpreterExternV1.sol/interface.IInterpreterExternV1.html">IInterpreterExternV1</a></li>
<li><a href="src/interface/IInterpreterStoreV1.sol/type.FullyQualifiedNamespace.html">FullyQualifiedNamespace</a></li>
<li><a href="src/interface/IInterpreterStoreV1.sol/interface.IInterpreterStoreV1.html">IInterpreterStoreV1</a></li>
<li><a href="src/interface/IInterpreterStoreV1.sol/constants.IInterpreterStoreV1.html">IInterpreterStoreV1 constants</a></li>
<li><a href="src/interface/IInterpreterV1.sol/type.SourceIndex.html">SourceIndex</a></li>
<li><a href="src/interface/IInterpreterV1.sol/type.EncodedDispatch.html">EncodedDispatch</a></li>
<li><a href="src/interface/IInterpreterV1.sol/type.StateNamespace.html">StateNamespace</a></li>
<li><a href="src/interface/IInterpreterV1.sol/type.Operand.html">Operand</a></li>
<li><a href="src/interface/IInterpreterV1.sol/interface.IInterpreterV1.html">IInterpreterV1</a></li>
<li><a href="src/interface/IInterpreterV1.sol/constants.IInterpreterV1.html">IInterpreterV1 constants</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-3"><a class="header" href="#contents-3">Contents</a></h1>
<ul>
<li><a href="src/interface/deprecated/IInterpreterCallerV1.sol/struct.SignedContext.html">SignedContext</a></li>
<li><a href="src/interface/deprecated/IInterpreterCallerV1.sol/interface.IInterpreterCallerV1.html">IInterpreterCallerV1</a></li>
<li><a href="src/interface/deprecated/IInterpreterCallerV1.sol/constants.IInterpreterCallerV1.html">IInterpreterCallerV1 constants</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signedcontext"><a class="header" href="#signedcontext">SignedContext</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/deprecated/IInterpreterCallerV1.sol">Git Source</a></p>
<p>Typed embodiment of some context data with associated signer and signature.
The signature MUST be over the packed encoded bytes of the context array,
i.e. the context array concatenated as bytes without the length prefix, then
hashed, then handled as per EIP-191 to produce a final hash to be signed.
The calling contract (likely with the help of <code>LibContext</code>) is responsible
for ensuring the authenticity of the signature, but not authorizing <em>who</em> can
sign. IN ADDITION to authorisation of the signer to known-good entities the
expression is also responsible for:</p>
<ul>
<li>Enforcing the context is the expected data (e.g. with a domain separator)</li>
<li>Tracking and enforcing nonces if signed contexts are only usable one time</li>
<li>Tracking and enforcing uniqueness of signed data if relevant</li>
<li>Checking and enforcing expiry times if present and relevant in the context</li>
<li>Many other potential constraints that expressions may want to enforce
EIP-1271 smart contract signatures are supported in addition to EOA
signatures via. the Open Zeppelin <code>SignatureChecker</code> library, which is
wrapped by <code>LibContext.build</code>. As smart contract signatures are checked
onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply
return <code>false</code> when it previously returned <code>true</code>.</li>
</ul>
<pre><code class="language-solidity">struct SignedContext {
    address signer;
    bytes signature;
    uint256[] context;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iinterpretercallerv1"><a class="header" href="#iinterpretercallerv1">IInterpreterCallerV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/deprecated/IInterpreterCallerV1.sol">Git Source</a></p>
<p>A contract that calls an <code>IInterpreterV1</code> via. <code>eval</code>. There are near
zero requirements on a caller other than:</p>
<ul>
<li>Emit some meta about itself upon construction so humans know what the
contract does</li>
<li>Provide the context, which can be built in a standard way by <code>LibContext</code></li>
<li>Handle the stack array returned from <code>eval</code></li>
<li>OPTIONALLY emit the <code>Context</code> event</li>
<li>OPTIONALLY set state on the <code>IInterpreterStoreV1</code> returned from eval.</li>
</ul>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<h3 id="context"><a class="header" href="#context">Context</a></h3>
<p>Calling contracts SHOULD emit <code>Context</code> before calling <code>eval</code> if they
are able. Notably <code>eval</code> MAY be called within a static call which means
that events cannot be emitted, in which case this does not apply. It MAY
NOT be useful to emit this multiple times for several eval calls if they
all share a common context, in which case a single emit is sufficient.</p>
<pre><code class="language-solidity">event Context(address sender, uint256[][] context);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-1"><a class="header" href="#constants-1">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/deprecated/IInterpreterCallerV1.sol">Git Source</a></p>
<h3 id="signed_context_signer_offset"><a class="header" href="#signed_context_signer_offset">SIGNED_CONTEXT_SIGNER_OFFSET</a></h3>
<pre><code class="language-solidity">uint256 constant SIGNED_CONTEXT_SIGNER_OFFSET = 0;
</code></pre>
<h3 id="signed_context_context_offset"><a class="header" href="#signed_context_context_offset">SIGNED_CONTEXT_CONTEXT_OFFSET</a></h3>
<pre><code class="language-solidity">uint256 constant SIGNED_CONTEXT_CONTEXT_OFFSET = 0x20;
</code></pre>
<h3 id="signed_context_signature_offset"><a class="header" href="#signed_context_signature_offset">SIGNED_CONTEXT_SIGNATURE_OFFSET</a></h3>
<pre><code class="language-solidity">uint256 constant SIGNED_CONTEXT_SIGNATURE_OFFSET = 0x40;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-4"><a class="header" href="#contents-4">Contents</a></h1>
<ul>
<li><a href="src/interface/unstable/IDebugExpressionDeployerV1.sol/interface.IDebugExpressionDeployerV1.html">IDebugExpressionDeployerV1</a></li>
<li><a href="src/interface/unstable/IDebugInterpreterV1.sol/interface.IDebugInterpreterV1.html">IDebugInterpreterV1</a></li>
<li><a href="src/interface/unstable/IExpressionDeployerV2.sol/interface.IExpressionDeployerV2.html">IExpressionDeployerV2</a></li>
<li><a href="src/interface/unstable/IExpressionDeployerV2.sol/constants.IExpressionDeployerV2.html">IExpressionDeployerV2 constants</a></li>
<li><a href="src/interface/unstable/IParserV1.sol/interface.IParserV1.html">IParserV1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idebugexpressiondeployerv1"><a class="header" href="#idebugexpressiondeployerv1">IDebugExpressionDeployerV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/unstable/IDebugExpressionDeployerV1.sol">Git Source</a></p>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<h3 id="offchaindebugeval-2"><a class="header" href="#offchaindebugeval-2">offchainDebugEval</a></h3>
<pre><code class="language-solidity">function offchainDebugEval(
    bytes[] memory sources,
    uint256[] memory constants,
    FullyQualifiedNamespace namespace,
    uint256[][] memory context,
    SourceIndex sourceIndex,
    uint256[] memory initialStack,
    uint8 minOutputs
) external view returns (uint256[] memory finalStack, uint256[] memory kvs);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idebuginterpreterv1"><a class="header" href="#idebuginterpreterv1">IDebugInterpreterV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/unstable/IDebugInterpreterV1.sol">Git Source</a></p>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<h3 id="offchaindebugeval-3"><a class="header" href="#offchaindebugeval-3">offchainDebugEval</a></h3>
<pre><code class="language-solidity">function offchainDebugEval(
    IInterpreterStoreV1 store,
    FullyQualifiedNamespace namespace,
    bytes[] calldata compiledSources,
    uint256[] calldata constants,
    uint256[][] calldata context,
    uint256[] calldata initialStack,
    SourceIndex sourceIndex_
) external view returns (uint256[] calldata finalStack, uint256[] calldata kvs);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iexpressiondeployerv2"><a class="header" href="#iexpressiondeployerv2">IExpressionDeployerV2</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/unstable/IExpressionDeployerV2.sol">Git Source</a></p>
<p>Companion to <code>IInterpreterV1</code> responsible for onchain static code
analysis and deploying expressions. Each <code>IExpressionDeployerV2</code> is tightly
coupled at the bytecode level to some interpreter that it knows how to
analyse and deploy expressions for. The expression deployer can perform an
integrity check &quot;dry run&quot; of candidate source code for the intepreter. The
critical analysis/transformation includes:</p>
<ul>
<li>Enforcement of no out of bounds memory reads/writes</li>
<li>Calculation of memory required to eval the stack with a single allocation</li>
<li>Replacing index based opcodes with absolute interpreter function pointers</li>
<li>Enforcement that all opcodes and operands used exist and are valid
This analysis is highly sensitive to the specific implementation and position
of all opcodes and function pointers as compiled into the interpreter. This
is what makes the coupling between an interpreter and expression deployer
so tight. Ideally all responsibilities would be handled by a single contract
but this introduces code size issues quickly by roughly doubling the compiled
logic of each opcode (half for the integrity check and half for evaluation).
Interpreters MUST assume that expression deployers are malicious and fail
gracefully if the integrity check is corrupt/bypassed and/or function
pointers are incorrect, etc. i.e. the interpreter MUST always return a stack
from <code>eval</code> in a read only way or error. I.e. it is the expression deployer's
responsibility to do everything it can to prevent undefined behaviour in the
interpreter, and the interpreter's responsibility to handle the expression
deployer completely failing to do so.</li>
</ul>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<h3 id="deployexpression-1"><a class="header" href="#deployexpression-1">deployExpression</a></h3>
<p>Expressions are expected to be deployed onchain as immutable contract
code with a first class address like any other contract or account.
Technically this is optional in the sense that all the tools required to
eval some expression and define all its opcodes are available as
libraries.
In practise there are enough advantages to deploying the sources directly
onchain as contract data and loading them from the interpreter at eval:</p>
<ul>
<li>Loading and storing binary data is gas efficient as immutable contract
data</li>
<li>Expressions need to be immutable between their deploy time integrity
check and runtime evaluation</li>
<li>Passing the address of an expression through calldata to an interpreter
is cheaper than passing an entire expression through calldata</li>
<li>Conceptually a very simple approach, even if implementations like
SSTORE2 are subtle under the hood
The expression deployer MUST perform an integrity check of the source
code before it puts the expression onchain at a known address. The
integrity check MUST at a minimum (it is free to do additional static
analysis) calculate the memory required to be allocated for the stack in
total, and that no out of bounds memory reads/writes occur within this
stack. A simple example of an invalid source would be one that pushes one
value to the stack then attempts to pops two values, clearly we cannot
remove more values than we added. The <code>IExpressionDeployerV2</code> MUST revert
in the case of any integrity failure, all integrity checks MUST pass in
order for the deployment to complete.
Once the integrity check is complete the <code>IExpressionDeployerV2</code> MUST do
any additional processing required by its paired interpreter.
For example, the <code>IExpressionDeployerV2</code> MAY NEED to replace the indexed
opcodes in the <code>ExpressionConfig</code> sources with real function pointers
from the corresponding interpreter.</li>
</ul>
<pre><code class="language-solidity">function deployExpression(bytes[] memory sources, uint256[] memory constants, uint8[] memory minOutputs)
    external
    returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sources</code></td><td><code>bytes[]</code></td><td>Sources verbatim. These sources MUST be provided in their sequential/index opcode form as the deployment process will need to index into BOTH the integrity check and the final runtime function pointers. This will be emitted in an event for offchain processing to use the indexed opcode sources. The first N sources are considered entrypoints and will be integrity checked by the expression deployer against a starting stack height of 0. Non-entrypoint sources MAY be provided for internal use such as the <code>call</code> opcode but will NOT be integrity checked UNLESS entered by an opcode in an entrypoint.</td></tr>
<tr><td><code>constants</code></td><td><code>uint256[]</code></td><td>Constants verbatim. Constants are provided alongside sources rather than inline as it allows us to avoid variable length opcodes and can be more memory efficient if the same constant is referenced several times from the sources.</td></tr>
<tr><td><code>minOutputs</code></td><td><code>uint8[]</code></td><td>The first N sources on the state config are entrypoints to the expression where N is the length of the <code>minOutputs</code> array. Each item in the <code>minOutputs</code> array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>interpreter</code></td><td><code>IInterpreterV1</code></td><td>The interpreter the deployer believes it is qualified to perform integrity checks on behalf of.</td></tr>
<tr><td><code>store</code></td><td><code>IInterpreterStoreV1</code></td><td>The interpreter store the deployer believes is compatible with the interpreter.</td></tr>
<tr><td><code>expression</code></td><td><code>address</code></td><td>The address of the deployed onchain expression. MUST be valid according to all integrity checks the deployer is aware of.</td></tr>
</tbody></table>
</div>
<h2 id="events-2"><a class="header" href="#events-2">Events</a></h2>
<h3 id="dispair"><a class="header" href="#dispair">DISpair</a></h3>
<p>This is the literal InterpreterOpMeta bytes to be used offchain to make
sense of the opcodes in this interpreter deployment, as a human. For
formats like json that make heavy use of boilerplate, repetition and
whitespace, some kind of compression is recommended.</p>
<pre><code class="language-solidity">event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-2"><a class="header" href="#constants-2">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/unstable/IExpressionDeployerV2.sol">Git Source</a></p>
<h3 id="ierc1820_name_iexpression_deployer_v2"><a class="header" href="#ierc1820_name_iexpression_deployer_v2">IERC1820_NAME_IEXPRESSION_DEPLOYER_V2</a></h3>
<pre><code class="language-solidity">string constant IERC1820_NAME_IEXPRESSION_DEPLOYER_V2 = &quot;IExpressionDeployerV2&quot;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iparserv1"><a class="header" href="#iparserv1">IParserV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/unstable/IParserV1.sol">Git Source</a></p>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<h3 id="parse-1"><a class="header" href="#parse-1">parse</a></h3>
<pre><code class="language-solidity">function parse(bytes memory data) external pure returns (bytes[] memory, uint256[] memory);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iexpressiondeployerv1"><a class="header" href="#iexpressiondeployerv1">IExpressionDeployerV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IExpressionDeployerV1.sol">Git Source</a></p>
<p>Companion to <code>IInterpreterV1</code> responsible for onchain static code
analysis and deploying expressions. Each <code>IExpressionDeployerV1</code> is tightly
coupled at the bytecode level to some interpreter that it knows how to
analyse and deploy expressions for. The expression deployer can perform an
integrity check &quot;dry run&quot; of candidate source code for the intepreter. The
critical analysis/transformation includes:</p>
<ul>
<li>Enforcement of no out of bounds memory reads/writes</li>
<li>Calculation of memory required to eval the stack with a single allocation</li>
<li>Replacing index based opcodes with absolute interpreter function pointers</li>
<li>Enforcement that all opcodes and operands used exist and are valid
This analysis is highly sensitive to the specific implementation and position
of all opcodes and function pointers as compiled into the interpreter. This
is what makes the coupling between an interpreter and expression deployer
so tight. Ideally all responsibilities would be handled by a single contract
but this introduces code size issues quickly by roughly doubling the compiled
logic of each opcode (half for the integrity check and half for evaluation).
Interpreters MUST assume that expression deployers are malicious and fail
gracefully if the integrity check is corrupt/bypassed and/or function
pointers are incorrect, etc. i.e. the interpreter MUST always return a stack
from <code>eval</code> in a read only way or error. I.e. it is the expression deployer's
responsibility to do everything it can to prevent undefined behaviour in the
interpreter, and the interpreter's responsibility to handle the expression
deployer completely failing to do so.</li>
</ul>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<h3 id="deployexpression-2"><a class="header" href="#deployexpression-2">deployExpression</a></h3>
<p>Expressions are expected to be deployed onchain as immutable contract
code with a first class address like any other contract or account.
Technically this is optional in the sense that all the tools required to
eval some expression and define all its opcodes are available as
libraries.
In practise there are enough advantages to deploying the sources directly
onchain as contract data and loading them from the interpreter at eval:</p>
<ul>
<li>Loading and storing binary data is gas efficient as immutable contract
data</li>
<li>Expressions need to be immutable between their deploy time integrity
check and runtime evaluation</li>
<li>Passing the address of an expression through calldata to an interpreter
is cheaper than passing an entire expression through calldata</li>
<li>Conceptually a very simple approach, even if implementations like
SSTORE2 are subtle under the hood
The expression deployer MUST perform an integrity check of the source
code before it puts the expression onchain at a known address. The
integrity check MUST at a minimum (it is free to do additional static
analysis) calculate the memory required to be allocated for the stack in
total, and that no out of bounds memory reads/writes occur within this
stack. A simple example of an invalid source would be one that pushes one
value to the stack then attempts to pops two values, clearly we cannot
remove more values than we added. The <code>IExpressionDeployerV1</code> MUST revert
in the case of any integrity failure, all integrity checks MUST pass in
order for the deployment to complete.
Once the integrity check is complete the <code>IExpressionDeployerV1</code> MUST do
any additional processing required by its paired interpreter.
For example, the <code>IExpressionDeployerV1</code> MAY NEED to replace the indexed
opcodes in the <code>ExpressionConfig</code> sources with real function pointers
from the corresponding interpreter.</li>
</ul>
<pre><code class="language-solidity">function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)
    external
    returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sources</code></td><td><code>bytes[]</code></td><td>Sources verbatim. These sources MUST be provided in their sequential/index opcode form as the deployment process will need to index into BOTH the integrity check and the final runtime function pointers. This will be emitted in an event for offchain processing to use the indexed opcode sources. The first N sources are considered entrypoints and will be integrity checked by the expression deployer against a starting stack height of 0. Non-entrypoint sources MAY be provided for internal use such as the <code>call</code> opcode but will NOT be integrity checked UNLESS entered by an opcode in an entrypoint.</td></tr>
<tr><td><code>constants</code></td><td><code>uint256[]</code></td><td>Constants verbatim. Constants are provided alongside sources rather than inline as it allows us to avoid variable length opcodes and can be more memory efficient if the same constant is referenced several times from the sources.</td></tr>
<tr><td><code>minOutputs</code></td><td><code>uint256[]</code></td><td>The first N sources on the state config are entrypoints to the expression where N is the length of the <code>minOutputs</code> array. Each item in the <code>minOutputs</code> array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>interpreter</code></td><td><code>IInterpreterV1</code></td><td>The interpreter the deployer believes it is qualified to perform integrity checks on behalf of.</td></tr>
<tr><td><code>store</code></td><td><code>IInterpreterStoreV1</code></td><td>The interpreter store the deployer believes is compatible with the interpreter.</td></tr>
<tr><td><code>expression</code></td><td><code>address</code></td><td>The address of the deployed onchain expression. MUST be valid according to all integrity checks the deployer is aware of.</td></tr>
</tbody></table>
</div>
<h2 id="events-3"><a class="header" href="#events-3">Events</a></h2>
<h3 id="dispair-1"><a class="header" href="#dispair-1">DISpair</a></h3>
<p>This is the literal InterpreterOpMeta bytes to be used offchain to make
sense of the opcodes in this interpreter deployment, as a human. For
formats like json that make heavy use of boilerplate, repetition and
whitespace, some kind of compression is recommended.</p>
<pre><code class="language-solidity">event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-3"><a class="header" href="#constants-3">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IExpressionDeployerV1.sol">Git Source</a></p>
<h3 id="ierc1820_name_iexpression_deployer_v1"><a class="header" href="#ierc1820_name_iexpression_deployer_v1">IERC1820_NAME_IEXPRESSION_DEPLOYER_V1</a></h3>
<pre><code class="language-solidity">string constant IERC1820_NAME_IEXPRESSION_DEPLOYER_V1 = &quot;IExpressionDeployerV1&quot;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signedcontextv1"><a class="header" href="#signedcontextv1">SignedContextV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterCallerV2.sol">Git Source</a></p>
<p>Typed embodiment of some context data with associated signer and signature.
The signature MUST be over the packed encoded bytes of the context array,
i.e. the context array concatenated as bytes without the length prefix, then
hashed, then handled as per EIP-191 to produce a final hash to be signed.
The calling contract (likely with the help of <code>LibContext</code>) is responsible
for ensuring the authenticity of the signature, but not authorizing <em>who</em> can
sign. IN ADDITION to authorisation of the signer to known-good entities the
expression is also responsible for:</p>
<ul>
<li>Enforcing the context is the expected data (e.g. with a domain separator)</li>
<li>Tracking and enforcing nonces if signed contexts are only usable one time</li>
<li>Tracking and enforcing uniqueness of signed data if relevant</li>
<li>Checking and enforcing expiry times if present and relevant in the context</li>
<li>Many other potential constraints that expressions may want to enforce
EIP-1271 smart contract signatures are supported in addition to EOA
signatures via. the Open Zeppelin <code>SignatureChecker</code> library, which is
wrapped by <code>LibContext.build</code>. As smart contract signatures are checked
onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply
return <code>false</code> when it previously returned <code>true</code>.</li>
</ul>
<pre><code class="language-solidity">struct SignedContextV1 {
    address signer;
    uint256[] context;
    bytes signature;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iinterpretercallerv2"><a class="header" href="#iinterpretercallerv2">IInterpreterCallerV2</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterCallerV2.sol">Git Source</a></p>
<p>A contract that calls an <code>IInterpreterV1</code> via. <code>eval</code>. There are near
zero requirements on a caller other than:</p>
<ul>
<li>Emit some meta about itself upon construction so humans know what the
contract does</li>
<li>Provide the context, which can be built in a standard way by <code>LibContext</code></li>
<li>Handle the stack array returned from <code>eval</code></li>
<li>OPTIONALLY emit the <code>Context</code> event</li>
<li>OPTIONALLY set state on the <code>IInterpreterStoreV1</code> returned from eval.</li>
</ul>
<h2 id="events-4"><a class="header" href="#events-4">Events</a></h2>
<h3 id="context-1"><a class="header" href="#context-1">Context</a></h3>
<p>Calling contracts SHOULD emit <code>Context</code> before calling <code>eval</code> if they
are able. Notably <code>eval</code> MAY be called within a static call which means
that events cannot be emitted, in which case this does not apply. It MAY
NOT be useful to emit this multiple times for several eval calls if they
all share a common context, in which case a single emit is sufficient.</p>
<pre><code class="language-solidity">event Context(address sender, uint256[][] context);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-4"><a class="header" href="#constants-4">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterCallerV2.sol">Git Source</a></p>
<h3 id="signed_context_signer_offset-1"><a class="header" href="#signed_context_signer_offset-1">SIGNED_CONTEXT_SIGNER_OFFSET</a></h3>
<pre><code class="language-solidity">uint256 constant SIGNED_CONTEXT_SIGNER_OFFSET = 0;
</code></pre>
<h3 id="signed_context_context_offset-1"><a class="header" href="#signed_context_context_offset-1">SIGNED_CONTEXT_CONTEXT_OFFSET</a></h3>
<pre><code class="language-solidity">uint256 constant SIGNED_CONTEXT_CONTEXT_OFFSET = 0x20;
</code></pre>
<h3 id="signed_context_signature_offset-1"><a class="header" href="#signed_context_signature_offset-1">SIGNED_CONTEXT_SIGNATURE_OFFSET</a></h3>
<pre><code class="language-solidity">uint256 constant SIGNED_CONTEXT_SIGNATURE_OFFSET = 0x40;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encodedexterndispatch"><a class="header" href="#encodedexterndispatch">EncodedExternDispatch</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterExternV1.sol">Git Source</a></p>
<pre><code class="language-solidity">type EncodedExternDispatch is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="externdispatch"><a class="header" href="#externdispatch">ExternDispatch</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterExternV1.sol">Git Source</a></p>
<pre><code class="language-solidity">type ExternDispatch is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iinterpreterexternv1"><a class="header" href="#iinterpreterexternv1">IInterpreterExternV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterExternV1.sol">Git Source</a></p>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<h3 id="extern-1"><a class="header" href="#extern-1">extern</a></h3>
<p>Handles a single dispatch.</p>
<pre><code class="language-solidity">function extern(ExternDispatch dispatch, uint256[] memory inputs) external view returns (uint256[] memory outputs);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>dispatch</code></td><td><code>ExternDispatch</code></td><td>Encoded information about the extern to dispatch. Analogous to the opcode/operand in the interpreter.</td></tr>
<tr><td><code>inputs</code></td><td><code>uint256[]</code></td><td>The array of inputs for the dispatched logic.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>outputs</code></td><td><code>uint256[]</code></td><td>The result of the dispatched logic.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="fullyqualifiednamespace"><a class="header" href="#fullyqualifiednamespace">FullyQualifiedNamespace</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterStoreV1.sol">Git Source</a></p>
<p>A fully qualified namespace includes the interpreter's own namespacing logic
IN ADDITION to the calling contract's requested <code>StateNamespace</code>. Typically
this involves hashing the <code>msg.sender</code> into the <code>StateNamespace</code> so that each
caller operates within its own disjoint state universe. Intepreters MUST NOT
allow either the caller nor any expression/word to modify this directly on
pain of potential key collisions on writes to the interpreter's own storage.</p>
<pre><code class="language-solidity">type FullyQualifiedNamespace is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iinterpreterstorev1"><a class="header" href="#iinterpreterstorev1">IInterpreterStoreV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterStoreV1.sol">Git Source</a></p>
<p>Tracks state changes on behalf of an interpreter. A single store can
handle state changes for many calling contracts, many interpreters and many
expressions. The store is responsible for ensuring that applying these state
changes is safe from key collisions with calls to <code>set</code> from different
<code>msg.sender</code> callers. I.e. it MUST NOT be possible for a caller to modify the
state changes associated with some other caller.
The store defines the shape of its own state changes, which is opaque to the
calling contract. For example, some store may treat the list of state changes
as a pairwise key/value set, and some other store may treat it as a literal
list to be stored as-is.
Each interpreter decides for itself which store to use based on the
compatibility of its own opcodes.
The store MUST assume the state changes have been corrupted by the calling
contract due to bugs or malicious intent, and enforce state isolation between
callers despite arbitrarily invalid state changes. The store MUST revert if
it can detect invalid state changes, such as a key/value list having an odd
number of items, but this MAY NOT be possible if the corruption is
undetectable.</p>
<h2 id="functions-11"><a class="header" href="#functions-11">Functions</a></h2>
<h3 id="set-1"><a class="header" href="#set-1">set</a></h3>
<p>Mutates the interpreter store in bulk. The bulk values are provided in
the form of a <code>uint256[]</code> which can be treated e.g. as pairwise keys and
values to be stored in a Solidity mapping. The <code>IInterpreterStoreV1</code>
defines the meaning of the <code>uint256[]</code> for its own storage logic.</p>
<pre><code class="language-solidity">function set(StateNamespace namespace, uint256[] calldata kvs) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>namespace</code></td><td><code>StateNamespace</code></td><td>The unqualified namespace for the set that MUST be fully qualified by the <code>IInterpreterStoreV1</code> to prevent key collisions between callers. The fully qualified namespace forms a compound key with the keys for each value to set.</td></tr>
<tr><td><code>kvs</code></td><td><code>uint256[]</code></td><td>The list of changes to apply to the store's internal state.</td></tr>
</tbody></table>
</div>
<h3 id="get-1"><a class="header" href="#get-1">get</a></h3>
<p>Given a fully qualified namespace and key, return the associated value.
Ostensibly the interpreter can use this to implement opcodes that read
previously set values. The interpreter MUST apply the same qualification
logic as the store that it uses to guarantee consistent round tripping of
data and prevent malicious behaviours. Technically also allows onchain
reads of any set value from any contract, not just interpreters, but in
this case readers MUST be aware and handle inconsistencies between get
and set while the state changes are still in memory in the calling
context and haven't yet been persisted to the store.
<code>IInterpreterStoreV1</code> uses the same fallback behaviour for unset keys as
Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO <code>0</code>.</p>
<pre><code class="language-solidity">function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>namespace</code></td><td><code>FullyQualifiedNamespace</code></td><td>The fully qualified namespace to get a single value for.</td></tr>
<tr><td><code>key</code></td><td><code>uint256</code></td><td>The key to get the value for within the namespace.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The value OR ZERO IF NOT SET.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="constants-5"><a class="header" href="#constants-5">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterStoreV1.sol">Git Source</a></p>
<h3 id="no_store"><a class="header" href="#no_store">NO_STORE</a></h3>
<pre><code class="language-solidity">IInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sourceindex"><a class="header" href="#sourceindex">SourceIndex</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterV1.sol">Git Source</a></p>
<p><em>The index of a source within a deployed expression that can be evaluated
by an <code>IInterpreterV1</code>. MAY be an entrypoint or the index of a source called
internally such as by the <code>call</code> opcode.</em></p>
<pre><code class="language-solidity">type SourceIndex is uint16;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encodeddispatch"><a class="header" href="#encodeddispatch">EncodedDispatch</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterV1.sol">Git Source</a></p>
<p><em>Encoded information about a specific evaluation including the expression
address onchain, entrypoint and expected return values.</em></p>
<pre><code class="language-solidity">type EncodedDispatch is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statenamespace"><a class="header" href="#statenamespace">StateNamespace</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterV1.sol">Git Source</a></p>
<p><em>The namespace for state changes as requested by the calling contract.
The interpreter MUST apply this namespace IN ADDITION to namespacing by
caller etc.</em></p>
<pre><code class="language-solidity">type StateNamespace is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operand"><a class="header" href="#operand">Operand</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterV1.sol">Git Source</a></p>
<p><em>Additional bytes that can be used to configure a single opcode dispatch.
Commonly used to specify the number of inputs to a variadic function such
as addition or multiplication.</em></p>
<pre><code class="language-solidity">type Operand is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iinterpreterv1"><a class="header" href="#iinterpreterv1">IInterpreterV1</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterV1.sol">Git Source</a></p>
<h2 id="functions-12"><a class="header" href="#functions-12">Functions</a></h2>
<h3 id="functionpointers-1"><a class="header" href="#functionpointers-1">functionPointers</a></h3>
<p>Exposes the function pointers as <code>uint16</code> values packed into a single
<code>bytes</code> in the same order as they would be indexed into by opcodes. For
example, if opcode <code>2</code> should dispatch function at position <code>0x1234</code> then
the start of the returned bytes would be <code>0xXXXXXXXX1234</code> where <code>X</code> is
a placeholder for the function pointers of opcodes <code>0</code> and <code>1</code>.
<code>IExpressionDeployerV1</code> contracts use these function pointers to
&quot;compile&quot; the expression into something that an interpreter can dispatch
directly without paying gas to lookup the same at runtime. As the
validity of any integrity check and subsequent dispatch is highly
sensitive to both the function pointers and overall bytecode of the
interpreter, <code>IExpressionDeployerV1</code> contracts SHOULD implement guards
against accidentally being deployed onchain paired against an unknown
interpreter. It is very easy for an apparent compatible pairing to be
subtly and critically incompatible due to addition/removal/reordering of
opcodes and compiler optimisations on the interpreter bytecode.
This MAY return different values during construction vs. all other times
after the interpreter has been successfully deployed onchain. DO NOT rely
on function pointers reported during contract construction.</p>
<pre><code class="language-solidity">function functionPointers() external view returns (bytes memory);
</code></pre>
<h3 id="eval-1"><a class="header" href="#eval-1">eval</a></h3>
<p>The raison d'etre for an interpreter. Given some expression and per-call
additional contextual data, produce a stack of results and a set of state
changes that the caller MAY OPTIONALLY pass back to be persisted by a
call to <code>IInterpreterStoreV1.set</code>.</p>
<pre><code class="language-solidity">function eval(
    IInterpreterStoreV1 store,
    StateNamespace namespace,
    EncodedDispatch dispatch,
    uint256[][] calldata context
) external view returns (uint256[] memory stack, uint256[] memory kvs);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>store</code></td><td><code>IInterpreterStoreV1</code></td><td>The storage contract that the returned key/value pairs MUST be passed to IF the calling contract is in a non-static calling context. Static calling contexts MUST pass <code>address(0)</code>.</td></tr>
<tr><td><code>namespace</code></td><td><code>StateNamespace</code></td><td>The state namespace that will be fully qualified by the interpreter at runtime in order to perform gets on the underlying store. MUST be the same namespace passed to the store by the calling contract when sending the resulting key/value items to storage.</td></tr>
<tr><td><code>dispatch</code></td><td><code>EncodedDispatch</code></td><td>All the information required for the interpreter to load an expression, select an entrypoint and return the values expected by the caller. The interpreter MAY encode dispatches differently to <code>LibEncodedDispatch</code> but this WILL negatively impact compatibility for calling contracts that hardcode the encoding logic.</td></tr>
<tr><td><code>context</code></td><td><code>uint256[][]</code></td><td>A 2-dimensional array of data that can be indexed into at runtime by the interpreter. The calling contract is responsible for ensuring the authenticity and completeness of context data. The interpreter MUST revert at runtime if an expression attempts to index into some context value that is not provided by the caller. This implies that context reads cannot be checked for out of bounds reads at deploy time, as the runtime context MAY be provided in a different shape to what the expression is expecting. Same as <code>eval</code> but allowing the caller to specify a namespace under which the state changes will be applied. The interpeter MUST ensure that keys will never collide across namespaces, even if, for example: - The calling contract is malicious and attempts to craft a collision with state changes from another contract - The expression is malicious and attempts to craft a collision with other expressions evaluated by the same calling contract A malicious entity MAY have access to significant offchain resources to attempt to precompute key collisions through brute force. The collision resistance of namespaces should be comparable or equivalent to the collision resistance of the hashing algorithms employed by the blockchain itself, such as the design of <code>mapping</code> in Solidity that hashes each nested key to produce a collision resistant compound key.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>stack</code></td><td><code>uint256[]</code></td><td>The list of values produced by evaluating the expression. MUST NOT be longer than the maximum length specified by <code>dispatch</code>, if applicable.</td></tr>
<tr><td><code>kvs</code></td><td><code>uint256[]</code></td><td>A list of pairwise key/value items to be saved in the store.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="constants-6"><a class="header" href="#constants-6">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/interface/IInterpreterV1.sol">Git Source</a></p>
<h3 id="default_state_namespace"><a class="header" href="#default_state_namespace">DEFAULT_STATE_NAMESPACE</a></h3>
<p><em>The default state namespace MUST be used when a calling contract has no
particular opinion on or need for dynamic namespaces.</em></p>
<pre><code class="language-solidity">StateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-5"><a class="header" href="#contents-5">Contents</a></h1>
<ul>
<li><a href="src/lib//src/lib/caller">caller</a></li>
<li><a href="src/lib//src/lib/compile">compile</a></li>
<li><a href="src/lib//src/lib/eval">eval</a></li>
<li><a href="src/lib//src/lib/extern">extern</a></li>
<li><a href="src/lib//src/lib/integrity">integrity</a></li>
<li><a href="src/lib//src/lib/ns">ns</a></li>
<li><a href="src/lib//src/lib/op">op</a></li>
<li><a href="src/lib//src/lib/parse">parse</a></li>
<li><a href="src/lib//src/lib/state">state</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-6"><a class="header" href="#contents-6">Contents</a></h1>
<ul>
<li><a href="src/lib/caller/LibContext.sol/error.InvalidSignature.html">InvalidSignature</a></li>
<li><a href="src/lib/caller/LibContext.sol/library.LibContext.html">LibContext</a></li>
<li><a href="src/lib/caller/LibDeployerDiscoverable.sol/library.LibDeployerDiscoverable.html">LibDeployerDiscoverable</a></li>
<li><a href="src/lib/caller/LibEncodedDispatch.sol/library.LibEncodedDispatch.html">LibEncodedDispatch</a></li>
<li><a href="src/lib/caller/LibEvaluable.sol/struct.EvaluableConfig.html">EvaluableConfig</a></li>
<li><a href="src/lib/caller/LibEvaluable.sol/struct.Evaluable.html">Evaluable</a></li>
<li><a href="src/lib/caller/LibEvaluable.sol/library.LibEvaluable.html">LibEvaluable</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invalidsignature"><a class="header" href="#invalidsignature">InvalidSignature</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/caller/LibContext.sol">Git Source</a></p>
<p>Thrown when the ith signature from a list of signed contexts is invalid.</p>
<pre><code class="language-solidity">error InvalidSignature(uint256 i);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libcontext"><a class="header" href="#libcontext">LibContext</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/caller/LibContext.sol">Git Source</a></p>
<p>Conventions for working with context as a calling contract. All of
this functionality is OPTIONAL but probably useful for the majority of use
cases. By building and authenticating onchain, caller provided and signed
contexts all in a standard way the overall usability of context is greatly
improved for expression authors and readers. Any calling contract that can
match the context expectations of an existing expression is one large step
closer to compatibility and portability, inheriting network effects of what
has already been authored elsewhere.</p>
<h2 id="functions-13"><a class="header" href="#functions-13">Functions</a></h2>
<h3 id="base"><a class="header" href="#base">base</a></h3>
<p>The base context is the <code>msg.sender</code> and address of the calling contract.
As the interpreter itself is called via an external interface and may be
statically calling itself, it MAY NOT have any ability to inspect either
of these values. Even if this were not the case the calling contract
cannot assume the existence of some opcode(s) in the interpreter that
inspect the caller, so providing these two values as context is
sufficient to decouple the calling contract from the interpreter. It is
STRONGLY RECOMMENDED that even if the calling contract has &quot;no context&quot;
that it still provides this base to every <code>eval</code>.
Calling contracts DO NOT need to call this directly. It is built and
merged automatically into the standard context built by <code>build</code>.</p>
<pre><code class="language-solidity">function base() internal view returns (uint256[] memory);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256[]</code></td><td>The <code>msg.sender</code> and address of the calling contract using this library, as a context-compatible array.</td></tr>
</tbody></table>
</div>
<h3 id="hash"><a class="header" href="#hash">hash</a></h3>
<p>Standard hashing process over a single <code>SignedContextV1</code>. Notably used
to hash a list as <code>SignedContextV1[]</code> but could also be used to hash a
single <code>SignedContextV1</code> in isolation. Avoids allocating memory by
hashing each struct field in sequence within the memory scratch space.</p>
<pre><code class="language-solidity">function hash(SignedContextV1 memory signedContext) internal pure returns (bytes32 hashed);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>signedContext</code></td><td><code>SignedContextV1</code></td><td>The signed context to hash.</td></tr>
</tbody></table>
</div>
<h3 id="hash-1"><a class="header" href="#hash-1">hash</a></h3>
<p>Standard hashing process over a list of signed contexts. Situationally
useful if the calling contract wants to record that it has seen a set of
signed data then later compare it against some input (e.g. to ensure that
many calls of some function all share the same input values). Note that
unlike the internals of <code>build</code>, this hashes over the signer and the
signature, to ensure that some data cannot be re-signed and used under
a different provenance later.</p>
<pre><code class="language-solidity">function hash(SignedContextV1[] memory signedContexts) internal pure returns (bytes32 hashed);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>signedContexts</code></td><td><code>SignedContextV1[]</code></td><td>The list of signed contexts to hash over.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hashed</code></td><td><code>bytes32</code></td><td>The hash of the signed contexts.</td></tr>
</tbody></table>
</div>
<h3 id="build"><a class="header" href="#build">build</a></h3>
<p>Builds a standard 2-dimensional context array from base, calling and
signed contexts. Note that &quot;columns&quot; of a context array refer to each
<code>uint256[]</code> and each item within a <code>uint256[]</code> is a &quot;row&quot;.</p>
<pre><code class="language-solidity">function build(uint256[][] memory baseContext, SignedContextV1[] memory signedContexts)
    internal
    view
    returns (uint256[][] memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>baseContext</code></td><td><code>uint256[][]</code></td><td>Anything the calling contract can provide which MAY include input from the <code>msg.sender</code> of the calling contract. The default base context from <code>LibContext.base()</code> DOES NOT need to be provided by the caller, this matrix MAY be empty and will be simply merged into the final context. The base context matrix MUST contain a consistent number of columns from the calling contract so that the expression can always predict how many unsigned columns there will be when it runs.</td></tr>
<tr><td><code>signedContexts</code></td><td><code>SignedContextV1[]</code></td><td>Signed contexts are provided by the <code>msg.sender</code> but signed by a third party. The expression (author) defines <em>who</em> may sign and the calling contract authenticates the signature over the signed data. Technically <code>build</code> handles all the authentication inline for the calling contract so if some context builds it can be treated as authentic. The builder WILL REVERT if any of the signatures are invalid. Note two things about the structure of the final built context re: signed contexts: - The first column is a list of the signers in order of what they signed - The <code>msg.sender</code> can provide an arbitrary number of signed contexts so expressions DO NOT know exactly how many columns there are. The expression is responsible for defining e.g. a domain separator in a position that would force signed context to be provided in the &quot;correct&quot; order, rather than relying on the <code>msg.sender</code> to honestly present data in any particular structure/order.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="libdeployerdiscoverable"><a class="header" href="#libdeployerdiscoverable">LibDeployerDiscoverable</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/caller/LibDeployerDiscoverable.sol">Git Source</a></p>
<h2 id="functions-14"><a class="header" href="#functions-14">Functions</a></h2>
<h3 id="touchdeployer"><a class="header" href="#touchdeployer">touchDeployer</a></h3>
<p>Hack so that some deployer will emit an event with the sender as the
caller of <code>touchDeployer</code>. This MAY be needed by indexers such as
subgraph that can only index events from the first moment they are aware
of some contract. The deployer MUST be registered in ERC1820 registry
before it is touched, THEN the caller meta MUST be emitted after the
deployer is touched. This allows indexers such as subgraph to index the
deployer, then see the caller, then see the caller's meta emitted in the
same transaction.
This is NOT required if ANY other expression is deployed in the same
transaction as the caller meta, there only needs to be one expression on
ANY deployer known to ERC1820.</p>
<pre><code class="language-solidity">function touchDeployer(address deployer) internal;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libencodeddispatch"><a class="header" href="#libencodeddispatch">LibEncodedDispatch</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/caller/LibEncodedDispatch.sol">Git Source</a></p>
<p>Establishes and implements a convention for encoding an interpreter
dispatch. Handles encoding of several things required for efficient dispatch.</p>
<h2 id="functions-15"><a class="header" href="#functions-15">Functions</a></h2>
<h3 id="encode"><a class="header" href="#encode">encode</a></h3>
<p>Builds an <code>EncodedDispatch</code> from its constituent parts.</p>
<pre><code class="language-solidity">function encode(address expression, SourceIndex sourceIndex, uint16 maxOutputs)
    internal
    pure
    returns (EncodedDispatch);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>expression</code></td><td><code>address</code></td><td>The onchain address of the expression to run.</td></tr>
<tr><td><code>sourceIndex</code></td><td><code>SourceIndex</code></td><td>The index of the source to run within the expression as an entrypoint.</td></tr>
<tr><td><code>maxOutputs</code></td><td><code>uint16</code></td><td>The maximum outputs the caller can meaningfully use. If the interpreter returns a larger stack than this it is merely wasting gas across the external call boundary.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>EncodedDispatch</code></td><td>The encoded dispatch.</td></tr>
</tbody></table>
</div>
<h3 id="decode"><a class="header" href="#decode">decode</a></h3>
<p>Decodes an <code>EncodedDispatch</code> to its constituent parts.</p>
<pre><code class="language-solidity">function decode(EncodedDispatch dispatch_) internal pure returns (address, SourceIndex, uint16);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>dispatch_</code></td><td><code>EncodedDispatch</code></td><td>The <code>EncodedDispatch</code> to decode.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>The expression, source index, and max outputs as per <code>encode</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>SourceIndex</code></td><td></td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint16</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="evaluableconfig"><a class="header" href="#evaluableconfig">EvaluableConfig</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/caller/LibEvaluable.sol">Git Source</a></p>
<p>Standard struct that can be embedded in ABIs in a consistent format for
tooling to read/write. MAY be useful to bundle up the data required to call
<code>IExpressionDeployerV1</code> but is NOT mandatory.</p>
<pre><code class="language-solidity">struct EvaluableConfig {
    IExpressionDeployerV1 deployer;
    bytes[] sources;
    uint256[] constants;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluable"><a class="header" href="#evaluable">Evaluable</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/caller/LibEvaluable.sol">Git Source</a></p>
<p>Struct over the return of <code>IExpressionDeployerV1.deployExpression</code>
which MAY be more convenient to work with than raw addresses.</p>
<pre><code class="language-solidity">struct Evaluable {
    IInterpreterV1 interpreter;
    IInterpreterStoreV1 store;
    address expression;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libevaluable"><a class="header" href="#libevaluable">LibEvaluable</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/caller/LibEvaluable.sol">Git Source</a></p>
<p>Common logic to provide consistent implementations of common tasks
that could be arbitrarily/ambiguously implemented, but work much better if
consistently implemented.</p>
<h2 id="functions-16"><a class="header" href="#functions-16">Functions</a></h2>
<h3 id="hash-2"><a class="header" href="#hash-2">hash</a></h3>
<p>Hashes an <code>Evaluable</code>, ostensibly so that only the hash need be stored,
thus only storing a single <code>uint256</code> instead of 3x <code>uint160</code>.</p>
<pre><code class="language-solidity">function hash(Evaluable memory evaluable_) internal pure returns (bytes32 hash_);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>evaluable_</code></td><td><code>Evaluable</code></td><td>The evaluable to hash.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hash_</code></td><td><code>bytes32</code></td><td>Standard hash of the evaluable.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-7"><a class="header" href="#contents-7">Contents</a></h1>
<ul>
<li><a href="src/lib/compile/LibCompile.sol/library.LibCompile.html">LibCompile</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libcompile"><a class="header" href="#libcompile">LibCompile</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/compile/LibCompile.sol">Git Source</a></p>
<h2 id="functions-17"><a class="header" href="#functions-17">Functions</a></h2>
<h3 id="unsafecompile"><a class="header" href="#unsafecompile">unsafeCompile</a></h3>
<p>Given a source in opcodes compile to an equivalent source with real
function pointers for a given Interpreter contract. The &quot;compilation&quot;
involves simply replacing the opcode with the pointer at the index of
the opcode. i.e. opcode 4 will be replaced with <code>pointers_[4]</code>.
Relies heavily on the integrity checks ensuring opcodes used are not OOB
and that the pointers provided are valid and in the correct order. As the
expression deployer is typically handling compilation during
serialization, NOT the interpreter, the interpreter MUST guard against
the compilation being garbage or outright hostile during <code>eval</code> by
pointing to arbitrary internal functions of the interpreter.</p>
<pre><code class="language-solidity">function unsafeCompile(bytes memory source, bytes memory pointers) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>bytes</code></td><td>The input source as index based opcodes.</td></tr>
<tr><td><code>pointers</code></td><td><code>bytes</code></td><td>The function pointers ordered by index to replace the index based opcodes with.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-8"><a class="header" href="#contents-8">Contents</a></h1>
<ul>
<li><a href="src/lib/eval/LibEval.sol/library.LibEval.html">LibEval</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libeval"><a class="header" href="#libeval">LibEval</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/eval/LibEval.sol">Git Source</a></p>
<h2 id="functions-18"><a class="header" href="#functions-18">Functions</a></h2>
<h3 id="eval-2"><a class="header" href="#eval-2">eval</a></h3>
<p>The main eval loop. Does as little as possible as it is an extremely hot
performance and critical security path. Loads opcode/operand pairs from
a precompiled source in the interpreter state and calls the function
that the opcode points to. This function is in turn responsible for
actually pushing/popping from the stack, etc. As <code>eval</code> receives the
source index and stack top alongside its state, it supports recursive
calls via. opcodes that can manage scoped substacks, etc. without <code>eval</code>
needing to house that complexity itself.</p>
<pre><code class="language-solidity">function eval(InterpreterState memory state, SourceIndex sourceIndex, Pointer stackTop)
    internal
    view
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>state</code></td><td><code>InterpreterState</code></td><td>The interpreter state to evaluate a source over.</td></tr>
<tr><td><code>sourceIndex</code></td><td><code>SourceIndex</code></td><td>The index of the source to evaluate. MAY be an entrypoint or a nested call.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>The current stack top, MUST be equal to the stack bottom on the intepreter state if the current eval is for an entrypoint.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-9"><a class="header" href="#contents-9">Contents</a></h1>
<ul>
<li><a href="src/lib/extern/LibExtern.sol/library.LibExtern.html">LibExtern</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libextern"><a class="header" href="#libextern">LibExtern</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/extern/LibExtern.sol">Git Source</a></p>
<h2 id="functions-19"><a class="header" href="#functions-19">Functions</a></h2>
<h3 id="encodeexterndispatch"><a class="header" href="#encodeexterndispatch">encodeExternDispatch</a></h3>
<p>Converts an opcode and operand pair into a single 32-byte word.
The encoding scheme is:</p>
<ul>
<li>bits [0,16): the operand</li>
<li>bits [16,32): the opcode
IMPORTANT: The encoding process does not check that either the opcode or
operand fit within 16 bits. This is the responsibility of the caller.</li>
</ul>
<pre><code class="language-solidity">function encodeExternDispatch(uint256 opcode, Operand operand) internal pure returns (ExternDispatch);
</code></pre>
<h3 id="decodeexterndispatch"><a class="header" href="#decodeexterndispatch">decodeExternDispatch</a></h3>
<p>Inverse of <code>encodeExternDispatch</code>.</p>
<pre><code class="language-solidity">function decodeExternDispatch(ExternDispatch dispatch) internal pure returns (uint256, Operand);
</code></pre>
<h3 id="encodeexterncall"><a class="header" href="#encodeexterncall">encodeExternCall</a></h3>
<p>Encodes an extern address and dispatch pair into a single 32-byte word.
This is the full data required to actually call an extern contract.
The encoding scheme is:</p>
<ul>
<li>bits [0,160): the address of the extern contract</li>
<li>bits [160,176): the dispatch operand</li>
<li>bits [176,192): the dispatch opcode
Note that the high bits are implied by a correctly encoded
<code>ExternDispatch</code>. Use <code>encodeExternDispatch</code> to ensure this.
IMPORTANT: The encoding process does not check that any of the values
fit within their respective bit ranges. This is the responsibility of
the caller.</li>
</ul>
<pre><code class="language-solidity">function encodeExternCall(IInterpreterExternV1 extern, ExternDispatch dispatch)
    internal
    pure
    returns (EncodedExternDispatch);
</code></pre>
<h3 id="decodeexterncall"><a class="header" href="#decodeexterncall">decodeExternCall</a></h3>
<p>Inverse of <code>encodeExternCall</code>.</p>
<pre><code class="language-solidity">function decodeExternCall(EncodedExternDispatch dispatch)
    internal
    pure
    returns (IInterpreterExternV1, ExternDispatch);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-10"><a class="header" href="#contents-10">Contents</a></h1>
<ul>
<li><a href="src/lib/integrity/LibIntegrityCheck.sol/error.MinStackBottom.html">MinStackBottom</a></li>
<li><a href="src/lib/integrity/LibIntegrityCheck.sol/error.StackPopUnderflow.html">StackPopUnderflow</a></li>
<li><a href="src/lib/integrity/LibIntegrityCheck.sol/error.MinFinalStack.html">MinFinalStack</a></li>
<li><a href="src/lib/integrity/LibIntegrityCheck.sol/struct.IntegrityCheckState.html">IntegrityCheckState</a></li>
<li><a href="src/lib/integrity/LibIntegrityCheck.sol/library.LibIntegrityCheck.html">LibIntegrityCheck</a></li>
<li><a href="src/lib/integrity/LibIntegrityCheck.sol/constants.LibIntegrityCheck.html">LibIntegrityCheck constants</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minstackbottom"><a class="header" href="#minstackbottom">MinStackBottom</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/integrity/LibIntegrityCheck.sol">Git Source</a></p>
<p>It is a misconfiguration to set the initial stack bottom to zero or some
small value as this trivially exposes the integrity check to potential
underflow issues that are gas intensive to repeatedly guard against on every
pop. The initial stack bottom for an <code>IntegrityCheckState</code> should be
<code>INITIAL_STACK_BOTTOM</code> to safely avoid the need for underflow checks due to
pops and pushes.</p>
<pre><code class="language-solidity">error MinStackBottom(Pointer stackBottom);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stackpopunderflow"><a class="header" href="#stackpopunderflow">StackPopUnderflow</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/integrity/LibIntegrityCheck.sol">Git Source</a></p>
<p>The virtual stack top has underflowed the stack highwater (or zero) during an
integrity check. The highwater will initially be the stack bottom but MAY
move higher due to certain operations such as placing multiple outputs on the
stack or copying from a stack position. The highwater prevents subsequent
popping of values that are considered immutable.</p>
<pre><code class="language-solidity">error StackPopUnderflow(int256 stackHighwaterIndex, int256 stackTopIndex);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minfinalstack"><a class="header" href="#minfinalstack">MinFinalStack</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/integrity/LibIntegrityCheck.sol">Git Source</a></p>
<p>The final stack produced by some source did not hit the minimum required for
its calling context.</p>
<pre><code class="language-solidity">error MinFinalStack(uint256 minStackOutputs, int256 actualStackOutputs);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integritycheckstate"><a class="header" href="#integritycheckstate">IntegrityCheckState</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/integrity/LibIntegrityCheck.sol">Git Source</a></p>
<p>Running an integrity check is a stateful operation. As well as the basic
configuration of what is being checked such as the sources and size of the
constants, the current and maximum stack height is being recomputed on every
checked opcode. The stack is virtual during the integrity check so whatever
the <code>Pointer</code> values are during the check, it's always undefined
behaviour to actually try to read/write to them.</p>
<pre><code class="language-solidity">struct IntegrityCheckState {
    bytes[] sources;
    uint256 constantsLength;
    Pointer stackBottom;
    Pointer stackHighwater;
    Pointer stackMaxTop;
    function(IntegrityCheckState memory, Operand, Pointer)
        view
        returns (Pointer)[] integrityFunctionPointers;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libintegritycheck"><a class="header" href="#libintegritycheck">LibIntegrityCheck</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/integrity/LibIntegrityCheck.sol">Git Source</a></p>
<p>&quot;Dry run&quot; versions of the key logic from <code>LibStackPointer</code> that
allows us to simulate a virtual stack based on the Solidity type system
itself. The core loop of an integrity check is to dispatch an integrity-only
version of a runtime opcode that then uses <code>LibIntegrityCheck</code> to apply a
function that simulates a stack movement. The simulated stack movement will
move a pointer to memory in the same way as a real pop/push would at runtime
but without any associated logic or even allocating and writing data in
memory on the other side of the pointer. Every pop is checked for out of
bounds reads, even if it is an intermediate pop within the logic of a single
opcode. The <em>gross</em> stack movement is just as important as the net movement.
For example, consider a simple ERC20 total supply read. The <em>net</em> movement
of a total supply read is 0, it pops the token address then pushes the total
supply. However the <em>gross</em> movement is first -1 then +1, so we have to guard
against the -1 underflowing while reading the token address <em>during</em> the
simulated opcode dispatch. In general this can be subtle, complex and error
prone, which is why <code>LibIntegrityCheck</code> and <code>LibStackPointer</code> take function
signatures as arguments, so that the overloading mechanism in Solidity itself
enforces correct pop/push calculations for every opcode.</p>
<h2 id="functions-20"><a class="header" href="#functions-20">Functions</a></h2>
<h3 id="newstate"><a class="header" href="#newstate">newState</a></h3>
<p>Build a new integrity check state from sane defaults. The initialization
of the stack bottom and highwater are important to avoid underflows
during the integrity check.</p>
<pre><code class="language-solidity">function newState(
    bytes[] memory sources,
    uint256[] memory constants,
    function(IntegrityCheckState memory, Operand, Pointer)
            view
            returns (Pointer)[] memory integrityFns
) internal pure returns (IntegrityCheckState memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sources</code></td><td><code>bytes[]</code></td><td>The sources of the expression to check.</td></tr>
<tr><td><code>constants</code></td><td><code>uint256[]</code></td><td>The constants of the expression to check.</td></tr>
<tr><td><code>integrityFns</code></td><td><code>function (IntegrityCheckState memory, Operand, Pointer) view returns (Pointer)[]</code></td><td>The integrity check function pointers for each opcode.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>IntegrityCheckState</code></td><td>The new integrity check state.</td></tr>
</tbody></table>
</div>
<h3 id="syncstackmaxtop"><a class="header" href="#syncstackmaxtop">syncStackMaxTop</a></h3>
<p>If the given stack pointer is above the current state of the max stack
top, the max stack top will be moved to the stack pointer.
i.e. this works like <code>stackMaxTop = stackMaxTop.max(stackPointer)</code> but
with the type unwrapping boilerplate included for convenience.</p>
<pre><code class="language-solidity">function syncStackMaxTop(IntegrityCheckState memory integrityCheckState, Pointer stackPointer) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>The state of the current integrity check including the current max stack top.</td></tr>
<tr><td><code>stackPointer</code></td><td><code>Pointer</code></td><td>The stack pointer to compare and potentially swap the max stack top for.</td></tr>
</tbody></table>
</div>
<h3 id="ensureintegrity"><a class="header" href="#ensureintegrity">ensureIntegrity</a></h3>
<p>The main integrity check loop. Designed so that it can be called
recursively by the dispatched integrity opcodes to support arbitrary
nesting of sources and substacks, loops, etc.
If ANY of the integrity checks for ANY opcode fails the entire integrity
check will revert.</p>
<pre><code class="language-solidity">function ensureIntegrity(
    IntegrityCheckState memory integrityCheckState,
    SourceIndex sourceIndex,
    Pointer stackTop,
    uint8 minStackOutputs
) internal view returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>Current state of the integrity check passed by reference to allow for recursive/nested integrity checking.</td></tr>
<tr><td><code>sourceIndex</code></td><td><code>SourceIndex</code></td><td>The source to check the integrity of which can be either an entrypoint or a non-entrypoint source if this is a recursive call to <code>ensureIntegrity</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>The current top of the virtual stack as a pointer. This can be manipulated to create effective substacks/scoped/immutable runtime values by restricting how the <code>stackTop</code> can move at deploy time.</td></tr>
<tr><td><code>minStackOutputs</code></td><td><code>uint8</code></td><td>The minimum stack height required by the end of this integrity check. The caller MUST ensure that it sets this value high enough so that it can safely read enough values from the final stack without out of bounds reads. The external interface to the expression deployer accepts an array of minimum stack heights against entrypoints, but the internal checks can be recursive against non-entrypoints and each opcode such as <code>call</code> can build scoped stacks, etc. so here we just put defining the requirements back on the caller.</td></tr>
</tbody></table>
</div>
<h3 id="push"><a class="header" href="#push">push</a></h3>
<p>Push a single virtual item onto the virtual stack.
Simply moves the stack top up one and syncs the interpreter max stack
height with it if needed.</p>
<pre><code class="language-solidity">function push(IntegrityCheckState memory integrityCheckState, Pointer stackTop) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>The state of the current integrity check.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>The pointer to the virtual stack top for the current integrity check.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after it has pushed an item.</td></tr>
</tbody></table>
</div>
<h3 id="push-1"><a class="header" href="#push-1">push</a></h3>
<p>Overloaded <code>push</code> to support <code>n</code> pushes in a single movement.
<code>n</code> MAY be 0 and this is a virtual noop stack movement.</p>
<pre><code class="language-solidity">function push(IntegrityCheckState memory integrityCheckState, Pointer stackTop, uint256 n)
    internal
    pure
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>push</code>.</td></tr>
<tr><td><code>n</code></td><td><code>uint256</code></td><td>The number of items to push to the virtual stack.</td></tr>
</tbody></table>
</div>
<h3 id="pushignorehighwater"><a class="header" href="#pushignorehighwater">pushIgnoreHighwater</a></h3>
<p>As push for 0+ values. Does NOT move the highwater. This may be useful if
the highwater is already calculated somehow by the caller. This is also
dangerous if used incorrectly as it could allow uncaught underflows to
creep in.</p>
<pre><code class="language-solidity">function pushIgnoreHighwater(IntegrityCheckState memory integrityCheckState, Pointer stackTop, uint256 n)
    internal
    pure
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>push</code>.</td></tr>
<tr><td><code>n</code></td><td><code>uint256</code></td><td>The number of items to push to the virtual stack.</td></tr>
</tbody></table>
</div>
<h3 id="popunderflowcheck"><a class="header" href="#popunderflowcheck">popUnderflowCheck</a></h3>
<p>Ensures that pops have not underflowed the stack, i.e. that the stack
top is not below the stack bottom. We set a large stack bottom that is
impossible to underflow within gas limits with realistic pops so that
we don't have to deal with a numeric underflow of the stack top.</p>
<pre><code class="language-solidity">function popUnderflowCheck(IntegrityCheckState memory integrityCheckState, Pointer stackTop) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>As per <code>pop</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code>.</td></tr>
</tbody></table>
</div>
<h3 id="pop"><a class="header" href="#pop">pop</a></h3>
<p>Move the stock top down one item then check that it hasn't underflowed
the stack bottom. If all virtual stack movements are defined in terms
of pops and pushes this will enforce that the gross stack movements do
not underflow, which would lead to out of bounds stack reads at runtime.</p>
<pre><code class="language-solidity">function pop(IntegrityCheckState memory integrityCheckState, Pointer stackTop) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>The state of the current integrity check.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>The virtual stack top before an item is popped.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The virtual stack top after the pop.</td></tr>
</tbody></table>
</div>
<h3 id="pop-1"><a class="header" href="#pop-1">pop</a></h3>
<p>Overloaded <code>pop</code> to support <code>n</code> pops in a single movement.
<code>n</code> MAY be 0 and this is a virtual noop stack movement.</p>
<pre><code class="language-solidity">function pop(IntegrityCheckState memory integrityCheckState, Pointer stackTop, uint256 n)
    internal
    pure
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code>.</td></tr>
<tr><td><code>n</code></td><td><code>uint256</code></td><td>The number of items to pop off the virtual stack.</td></tr>
</tbody></table>
</div>
<h3 id="popignorehighwater"><a class="header" href="#popignorehighwater">popIgnoreHighwater</a></h3>
<p>DANGEROUS pop that does no underflow/highwater checks. The caller MUST
ensure that this does not result in illegal stack reads.</p>
<pre><code class="language-solidity">function popIgnoreHighwater(IntegrityCheckState memory, Pointer stackTop, uint256 n) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>IntegrityCheckState</code></td><td></td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code>.</td></tr>
<tr><td><code>n</code></td><td><code>uint256</code></td><td>as per <code>pop</code>.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn"><a class="header" href="#applyfn">applyFn</a></h3>
<p>Maps <code>function(uint256) internal view returns (uint256)</code> to pops and
pushes once. The function itself is irrelevant we only care about the
signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256) internal view returns (uint256)
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256) internal view returns (uint256)</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-1"><a class="header" href="#applyfn-1">applyFn</a></h3>
<p>Maps <code>function(uint256, uint256) internal view</code> to pops and pushes once.
The function itself is irrelevant we only care about the signature to
know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256) internal view
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256) internal view</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-2"><a class="header" href="#applyfn-2">applyFn</a></h3>
<p>Maps <code>function(uint256, uint256) internal view returns (uint256)</code> to
pops and pushes once. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256) internal view returns (uint256)
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256) internal view returns (uint256)</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfnn"><a class="header" href="#applyfnn">applyFnN</a></h3>
<p>Reduces <code>function(uint256, uint256) internal view returns (uint256)</code>over
N stack items. The function itself is irrelevant we only care about the
signature to know how many items are popped/pushed. This is the same as
calling <code>applyFn</code> N - 1 times in a loop, because the first reduction
takes two items off the stack to start the accumulator, then each
subsequent reduction takes one item off the stack to incorporate into the
accumulator.
As per LibOp the behaviour below n = 2 is somewhat arbitrary but is
defined as:</p>
<ul>
<li>n = 0: Value <code>0</code> is <em>pushed</em> to the stack.</li>
<li>n = 1: Noop.
Which is interpreted as:</li>
<li>n = 0: Falsey outcome.</li>
<li>n = 1: Accumulator without any further inputs = Identity.
Which pragmatically looks something like:</li>
<li>n = 0: <code>_: add();</code></li>
<li>n = 1: <code>_: add(1);</code></li>
</ul>
<pre><code class="language-solidity">function applyFnN(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256) internal view returns (uint256),
    uint256 n
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256) internal view returns (uint256)</code></td><td></td></tr>
<tr><td><code>n</code></td><td><code>uint256</code></td><td>The number of times the function is applied to the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied n times.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-3"><a class="header" href="#applyfn-3">applyFn</a></h3>
<p>Maps
<code>function(uint256, uint256, uint256) internal view returns (uint256)</code> to
pops and pushes once. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256, uint256) internal view returns (uint256)
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256, uint256) internal view returns (uint256)</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-4"><a class="header" href="#applyfn-4">applyFn</a></h3>
<p>Maps</p>
<pre><code>function(uint256, uint256, uint256, uint256)
internal
view
returns (uint256)
</code></pre>
<p>to pops and pushes once. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256, uint256, uint256)
            internal
            view
            returns (uint256)
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256, uint256, uint256) internal view returns (uint256)</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-5"><a class="header" href="#applyfn-5">applyFn</a></h3>
<p>Maps <code>function(Operand, uint256) internal view returns (uint256)</code> to
pops and pushes once. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.
The operand MUST NOT influence the stack movements if this application
is to be valid.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(Operand, uint256) internal view returns (uint256)
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (Operand, uint256) internal view returns (uint256)</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-6"><a class="header" href="#applyfn-6">applyFn</a></h3>
<p>Maps
<code>function(Operand, uint256, uint256) internal view returns (uint256)</code> to
pops and pushes once. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.
The operand MUST NOT influence the stack movements if this application
is to be valid.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(Operand, uint256, uint256) internal view returns (uint256)
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (Operand, uint256, uint256) internal view returns (uint256)</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-7"><a class="header" href="#applyfn-7">applyFn</a></h3>
<p>Maps <code>function(uint256[] memory) internal view returns (uint256)</code> to
pops and pushes once given that we know the length of the dynamic array
at deploy time. The function itself is irrelevant we only care about the
signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256[] memory) internal view returns (uint256),
    uint256 length
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256[] memory) internal view returns (uint256)</code></td><td></td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the dynamic input array.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-8"><a class="header" href="#applyfn-8">applyFn</a></h3>
<p>Maps</p>
<pre><code>function(uint256, uint256, uint256[] memory)
internal
view
returns (uint256)
</code></pre>
<p>to pops and pushes once given that we know the length of the dynamic
array at deploy time. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256, uint256[] memory)
            internal
            view
            returns (uint256),
    uint256 length
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256, uint256[] memory) internal view returns (uint256)</code></td><td></td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the dynamic input array.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-9"><a class="header" href="#applyfn-9">applyFn</a></h3>
<p>Maps</p>
<pre><code>function(uint256, uint256, uint256, uint256[] memory)
internal
view
returns (uint256)
</code></pre>
<p>to pops and pushes once given that we know the length of the dynamic
array at deploy time. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256, uint256, uint256[] memory)
            internal
            view
            returns (uint256),
    uint256 length
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256, uint256, uint256[] memory) internal view returns (uint256)</code></td><td></td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the dynamic input array.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-10"><a class="header" href="#applyfn-10">applyFn</a></h3>
<p>Maps</p>
<pre><code>function(uint256, uint256[] memory, uint256[] memory)
internal
view
returns (uint256[] memory)
</code></pre>
<p>to pops and pushes once given that we know the length of the dynamic
array at deploy time. The function itself is irrelevant we only care
about the signature to know how many items are popped/pushed.</p>
<pre><code class="language-solidity">function applyFn(
    IntegrityCheckState memory integrityCheckState,
    Pointer stackTop,
    function(uint256, uint256[] memory, uint256[] memory)
            internal
            view
            returns (uint256[] memory),
    uint256 length
) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>integrityCheckState</code></td><td><code>IntegrityCheckState</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>as per <code>pop</code> and <code>push</code>.</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>function (uint256, uint256[] memory, uint256[] memory) internal view returns (uint256[] memory)</code></td><td></td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the dynamic input array.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack top after the function has been applied once.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="constants-7"><a class="header" href="#constants-7">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/integrity/LibIntegrityCheck.sol">Git Source</a></p>
<h3 id="initial_stack_bottom"><a class="header" href="#initial_stack_bottom">INITIAL_STACK_BOTTOM</a></h3>
<p><em>The virtual stack pointers are never read or written so don't need to
point to a real location in memory. We only care that the stack never moves
below its starting point at the stack bottom. For the virtual stack used by
the integrity check we can start it in the middle of the <code>uint256</code> range and
achieve something analogous to signed integers with unsigned integer types.</em></p>
<pre><code class="language-solidity">Pointer constant INITIAL_STACK_BOTTOM = Pointer.wrap(0x20 ** 0x20);
</code></pre>
<h3 id="initial_stack_highwater"><a class="header" href="#initial_stack_highwater">INITIAL_STACK_HIGHWATER</a></h3>
<p><em>Highwater starts underneath stack bottom as it errors on an greater than
<em>or equal to</em> check.</em></p>
<pre><code class="language-solidity">Pointer constant INITIAL_STACK_HIGHWATER = Pointer.wrap(Pointer.unwrap(INITIAL_STACK_BOTTOM) - 0x20);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-11"><a class="header" href="#contents-11">Contents</a></h1>
<ul>
<li><a href="src/lib/ns/LibNamespace.sol/library.LibNamespace.html">LibNamespace</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libnamespace"><a class="header" href="#libnamespace">LibNamespace</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/ns/LibNamespace.sol">Git Source</a></p>
<h2 id="functions-21"><a class="header" href="#functions-21">Functions</a></h2>
<h3 id="qualifynamespace"><a class="header" href="#qualifynamespace">qualifyNamespace</a></h3>
<p>Standard way to elevate a caller-provided state namespace to a universal
namespace that is disjoint from all other caller-provided namespaces.
Essentially just hashes the <code>msg.sender</code> into the state namespace as-is.
This is deterministic such that the same combination of state namespace
and caller will produce the same fully qualified namespace, even across
multiple transactions/blocks.</p>
<pre><code class="language-solidity">function qualifyNamespace(StateNamespace stateNamespace, address sender)
    internal
    pure
    returns (FullyQualifiedNamespace qualifiedNamespace);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>stateNamespace</code></td><td><code>StateNamespace</code></td><td>The state namespace as specified by the caller.</td></tr>
<tr><td><code>sender</code></td><td><code>address</code></td><td>The caller this namespace is bound to.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>qualifiedNamespace</code></td><td><code>FullyQualifiedNamespace</code></td><td>A fully qualified namespace that cannot collide with any other state namespace specified by any other caller.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-12"><a class="header" href="#contents-12">Contents</a></h1>
<ul>
<li><a href="src/lib/op//src/lib/op/chainlink">chainlink</a></li>
<li><a href="src/lib/op//src/lib/op/evm">evm</a></li>
<li><a href="src/lib/op/LibAllStandardOpsNP.sol/error.BadDynamicLength.html">BadDynamicLength</a></li>
<li><a href="src/lib/op/LibAllStandardOpsNP.sol/library.LibAllStandardOpsNP.html">LibAllStandardOpsNP</a></li>
<li><a href="src/lib/op/LibAllStandardOpsNP.sol/constants.LibAllStandardOpsNP.html">LibAllStandardOpsNP constants</a></li>
<li><a href="src/lib/op/LibOp.sol/error.UnexpectedResultLength.html">UnexpectedResultLength</a></li>
<li><a href="src/lib/op/LibOp.sol/library.LibOp.html">LibOp</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-13"><a class="header" href="#contents-13">Contents</a></h1>
<ul>
<li><a href="src/lib/op/chainlink/LibOpChainlinkOraclePrice.sol/library.LibOpChainlinkOraclePrice.html">LibOpChainlinkOraclePrice</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libopchainlinkoracleprice"><a class="header" href="#libopchainlinkoracleprice">LibOpChainlinkOraclePrice</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/op/chainlink/LibOpChainlinkOraclePrice.sol">Git Source</a></p>
<h2 id="functions-22"><a class="header" href="#functions-22">Functions</a></h2>
<h3 id="f"><a class="header" href="#f">f</a></h3>
<p>Thin wrapper around <code>LibChainlink.price</code>.
Casts arguments to the types expected by <code>LibChainlink.price</code> without
checking their validity. <code>LibChainlink.price</code> will revert if the
arguments are clearly invalid, or there is a detectable issue with the
upstream Chainlink oracle (such as negative price or stale data).</p>
<pre><code class="language-solidity">function f(Operand operand, uint256 feed, uint256 staleAfter) internal view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>operand</code></td><td><code>Operand</code></td><td>The scaling flags.</td></tr>
<tr><td><code>feed</code></td><td><code>uint256</code></td><td>The address of the Chainlink oracle.</td></tr>
<tr><td><code>staleAfter</code></td><td><code>uint256</code></td><td>The number of seconds after which the price is stale. This is compared against the <code>updatedAt</code> field of the Chainlink oracle and the current timestamp, so functions as a max age on price data.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-14"><a class="header" href="#contents-14">Contents</a></h1>
<ul>
<li><a href="src/lib/op/evm/LibOpChainId.sol/library.LibOpChainId.html">LibOpChainId</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libopchainid"><a class="header" href="#libopchainid">LibOpChainId</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/op/evm/LibOpChainId.sol">Git Source</a></p>
<p>An opcode which pushes the current chain ID to the stack.</p>
<h2 id="functions-23"><a class="header" href="#functions-23">Functions</a></h2>
<h3 id="integrity"><a class="header" href="#integrity">integrity</a></h3>
<p>No special integrity checks are required for this opcode. Simply updates
the stack pointer.</p>
<pre><code class="language-solidity">function integrity(IntegrityCheckState memory integrityCheckState, Operand, Pointer stackTop)
    internal
    pure
    returns (Pointer);
</code></pre>
<h3 id="run"><a class="header" href="#run">run</a></h3>
<p>Pushes the current chain ID to the stack.</p>
<pre><code class="language-solidity">function run(InterpreterState memory, Operand, Pointer stackTop) internal view returns (Pointer);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="baddynamiclength"><a class="header" href="#baddynamiclength">BadDynamicLength</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/op/LibAllStandardOpsNP.sol">Git Source</a></p>
<p>Thrown when a dynamic length array is NOT 1 more than a fixed length array.
Should never happen outside a major breaking change to memory layouts.</p>
<pre><code class="language-solidity">error BadDynamicLength(uint256 dynamicLength, uint256 standardOpsLength);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liballstandardopsnp"><a class="header" href="#liballstandardopsnp">LibAllStandardOpsNP</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/op/LibAllStandardOpsNP.sol">Git Source</a></p>
<p>Every opcode available from the core repository laid out as a single
array to easily build function pointers for <code>IInterpreterV1</code>.</p>
<h2 id="functions-24"><a class="header" href="#functions-24">Functions</a></h2>
<h3 id="integrityfunctionpointers-1"><a class="header" href="#integrityfunctionpointers-1">integrityFunctionPointers</a></h3>
<p>All function pointers for the integrity checks of the standard opcodes.
Intended to be used internally by a deployer when building an expression.</p>
<pre><code class="language-solidity">function integrityFunctionPointers()
    internal
    pure
    returns (function(IntegrityCheckState memory, Operand, Pointer) view returns (Pointer)[] memory pointers);
</code></pre>
<h3 id="opcodefunctionpointers"><a class="header" href="#opcodefunctionpointers">opcodeFunctionPointers</a></h3>
<p>All function pointers for the standard opcodes. Intended to be used to
build a <code>IInterpreterV1</code> instance, specifically the <code>functionPointers</code>
method can just be a thin wrapper around this function.</p>
<pre><code class="language-solidity">function opcodeFunctionPointers() internal pure returns (bytes memory);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-8"><a class="header" href="#constants-8">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/op/LibAllStandardOpsNP.sol">Git Source</a></p>
<h3 id="all_standard_ops_length"><a class="header" href="#all_standard_ops_length">ALL_STANDARD_OPS_LENGTH</a></h3>
<p><em>Number of ops currently provided by <code>AllStandardOpsNP</code>.</em></p>
<pre><code class="language-solidity">uint256 constant ALL_STANDARD_OPS_LENGTH = 1;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedresultlength"><a class="header" href="#unexpectedresultlength">UnexpectedResultLength</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/op/LibOp.sol">Git Source</a></p>
<p>Thrown when the length of an array as the result of an applied function does
not match expectations.</p>
<pre><code class="language-solidity">error UnexpectedResultLength(uint256 expectedLength, uint256 actualLength);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libop"><a class="header" href="#libop">LibOp</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/op/LibOp.sol">Git Source</a></p>
<h2 id="functions-25"><a class="header" href="#functions-25">Functions</a></h2>
<h3 id="applyfn-11"><a class="header" href="#applyfn-11">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(Pointer pointer, function(uint256) internal view returns (uint256) f)
    internal
    view
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-12"><a class="header" href="#applyfn-12">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(Pointer pointer, function(uint256, uint256) internal view returns (uint256) f)
    internal
    view
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256, uint256) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-13"><a class="header" href="#applyfn-13">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(Pointer pointer, function(uint256, uint256, uint256) internal view returns (uint256) f)
    internal
    view
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256, uint256, uint256) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-14"><a class="header" href="#applyfn-14">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(
    Pointer pointer,
    function(uint256, uint256, uint256, uint256)
            internal
            view
            returns (uint256) f
) internal view returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256, uint256, uint256, uint256) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-15"><a class="header" href="#applyfn-15">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(Pointer pointer, function(Operand, uint256) internal view returns (uint256) f, Operand operand)
    internal
    view
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (Operand, uint256) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
<tr><td><code>operand</code></td><td><code>Operand</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-16"><a class="header" href="#applyfn-16">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(
    Pointer pointer,
    function(Operand, uint256, uint256) internal view returns (uint256) f,
    Operand operand
) internal view returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (Operand, uint256, uint256) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
<tr><td><code>operand</code></td><td><code>Operand</code></td><td>Operand is passed from the source instead of the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-17"><a class="header" href="#applyfn-17">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(Pointer pointer, function(uint256[] memory) internal view returns (uint256) f, uint256 length)
    internal
    view
    returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256[] memory) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the array to pass to f from the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-18"><a class="header" href="#applyfn-18">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(
    Pointer pointer,
    function(uint256, uint256, uint256[] memory)
            internal
            view
            returns (uint256) f,
    uint256 length
) internal view returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256, uint256, uint256[] memory) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the array to pass to f from the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>pointerAfter The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-19"><a class="header" href="#applyfn-19">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(
    Pointer pointer,
    function(uint256, uint256, uint256, uint256[] memory)
            internal
            view
            returns (uint256) f,
    uint256 length
) internal view returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256, uint256, uint256, uint256[] memory) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the array to pass to f from the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfn-20"><a class="header" href="#applyfn-20">applyFn</a></h3>
<p>Execute a function, reading and writing inputs and outputs on the stack.
The caller MUST ensure this does not result in unsafe reads and writes.</p>
<pre><code class="language-solidity">function applyFn(
    Pointer stackTop,
    function(uint256, uint256[] memory, uint256[] memory)
            internal
            view
            returns (uint256[] memory) f,
    uint256 length
) internal view returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>stackTop</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256, uint256[] memory, uint256[] memory) internal view returns (uint256[] memory)</code></td><td>The function to run on the stack.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The length of the arrays to pass to f from the stack.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div>
<h3 id="applyfnn-1"><a class="header" href="#applyfnn-1">applyFnN</a></h3>
<p>Reduce a function <code>f</code> <code>n</code> times, reading and writing inputs and the
accumulated result on the stack.
As <code>f</code> accepts 2 inputs and returns 1 output, we must somewhat
arbitrarily decide how to handle <code>n &lt; 2</code>. We DO NOT call <code>f</code>, instead:</p>
<ul>
<li><code>n=0</code> does NOT read any values. It pushes <code>0</code> to <code>pointer</code> always.</li>
<li><code>n=1</code> is treated as a noop. It can be interpreted as popping one word
from <code>pointer</code> to act as an accumulator, but then no susequent values
are applied to the accumulator, so it is pushed back to <code>pointer</code>. The
net result of popping and pushing some value is a noop.
The caller MUST ensure this does not result in unsafe reads and writes.</li>
</ul>
<pre><code class="language-solidity">function applyFnN(Pointer pointer, function(uint256, uint256) internal view returns (uint256) f, uint256 n)
    internal
    view
    returns (Pointer pointerAfter);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to read and write to.</td></tr>
<tr><td><code>f</code></td><td><code>function (uint256, uint256) internal view returns (uint256)</code></td><td>The function to run on the stack.</td></tr>
<tr><td><code>n</code></td><td><code>uint256</code></td><td>The number of times to apply f to accumulate a final result.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointerAfter</code></td><td><code>Pointer</code></td><td>The new stack top above the outputs of f.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-15"><a class="header" href="#contents-15">Contents</a></h1>
<ul>
<li><a href="src/lib/parse/LibCtPop.sol/library.LibCtPop.html">LibCtPop</a></li>
<li><a href="src/lib/parse/LibCtPop.sol/constants.LibCtPop.html">LibCtPop constants</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.MissingFinalSemi.html">MissingFinalSemi</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.UnexpectedLHSChar.html">UnexpectedLHSChar</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.UnexpectedRHSChar.html">UnexpectedRHSChar</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.UnexpectedRightParen.html">UnexpectedRightParen</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.WordSize.html">WordSize</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.UnknownWord.html">UnknownWord</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.MaxSources.html">MaxSources</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.DanglingSource.html">DanglingSource</a></li>
<li><a href="src/lib/parse/LibParse.sol/error.StackOverflow.html">StackOverflow</a></li>
<li><a href="src/lib/parse/LibParse.sol/struct.ParseState.html">ParseState</a></li>
<li><a href="src/lib/parse/LibParse.sol/library.LibParseState.html">LibParseState</a></li>
<li><a href="src/lib/parse/LibParse.sol/library.LibParse.html">LibParse</a></li>
<li><a href="src/lib/parse/LibParse.sol/constants.LibParse.html">LibParse constants</a></li>
<li><a href="src/lib/parse/LibParseMeta.sol/error.DuplicateFingerprint.html">DuplicateFingerprint</a></li>
<li><a href="src/lib/parse/LibParseMeta.sol/library.LibParseMeta.html">LibParseMeta</a></li>
<li><a href="src/lib/parse/LibParseMeta.sol/constants.LibParseMeta.html">LibParseMeta constants</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libctpop"><a class="header" href="#libctpop">LibCtPop</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibCtPop.sol">Git Source</a></p>
<h2 id="functions-26"><a class="header" href="#functions-26">Functions</a></h2>
<h3 id="ctpop"><a class="header" href="#ctpop">ctpop</a></h3>
<pre><code class="language-solidity">function ctpop(uint256 x) internal pure returns (uint256);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-9"><a class="header" href="#constants-9">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibCtPop.sol">Git Source</a></p>
<h3 id="ctpop_m1"><a class="header" href="#ctpop_m1">CTPOP_M1</a></h3>
<p><em>010101... for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M1 = 0x5555555555555555555555555555555555555555555555555555555555555555;
</code></pre>
<h3 id="ctpop_m2"><a class="header" href="#ctpop_m2">CTPOP_M2</a></h3>
<p><em>00110011.. for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M2 = 0x3333333333333333333333333333333333333333333333333333333333333333;
</code></pre>
<h3 id="ctpop_m4"><a class="header" href="#ctpop_m4">CTPOP_M4</a></h3>
<p><em>4 bits alternating for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M4 = 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F;
</code></pre>
<h3 id="ctpop_m8"><a class="header" href="#ctpop_m8">CTPOP_M8</a></h3>
<p><em>8 bits alternating for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M8 = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF;
</code></pre>
<h3 id="ctpop_m16"><a class="header" href="#ctpop_m16">CTPOP_M16</a></h3>
<p><em>16 bits alternating for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M16 = 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF;
</code></pre>
<h3 id="ctpop_m32"><a class="header" href="#ctpop_m32">CTPOP_M32</a></h3>
<p><em>32 bits alternating for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M32 = 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF;
</code></pre>
<h3 id="ctpop_m64"><a class="header" href="#ctpop_m64">CTPOP_M64</a></h3>
<p><em>64 bits alternating for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M64 = 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF;
</code></pre>
<h3 id="ctpop_m128"><a class="header" href="#ctpop_m128">CTPOP_M128</a></h3>
<p><em>128 bits alternating for ctpop</em></p>
<pre><code class="language-solidity">uint256 constant CTPOP_M128 = 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="missingfinalsemi"><a class="header" href="#missingfinalsemi">MissingFinalSemi</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>The expression does not finish with a semicolon (EOF).</p>
<pre><code class="language-solidity">error MissingFinalSemi(uint256 offset);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedlhschar"><a class="header" href="#unexpectedlhschar">UnexpectedLHSChar</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>Enountered an unexpected character on the LHS.</p>
<pre><code class="language-solidity">error UnexpectedLHSChar(uint256 offset, string char);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedrhschar"><a class="header" href="#unexpectedrhschar">UnexpectedRHSChar</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>Encountered an unexpected character on the RHS.</p>
<pre><code class="language-solidity">error UnexpectedRHSChar(uint256 offset, string char);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unexpectedrightparen"><a class="header" href="#unexpectedrightparen">UnexpectedRightParen</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>Encountered a right paren without a matching left paren.</p>
<pre><code class="language-solidity">error UnexpectedRightParen(uint256 offset);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wordsize"><a class="header" href="#wordsize">WordSize</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>Enountered a word that is longer than 32 bytes.</p>
<pre><code class="language-solidity">error WordSize(string word);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unknownword"><a class="header" href="#unknownword">UnknownWord</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>Parsed a word that is not in the meta.</p>
<pre><code class="language-solidity">error UnknownWord(bytes32 word);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maxsources"><a class="header" href="#maxsources">MaxSources</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>The parser exceeded the maximum number of sources that it can build.</p>
<pre><code class="language-solidity">error MaxSources();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="danglingsource"><a class="header" href="#danglingsource">DanglingSource</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>The parser encountered a dangling source. This is a bug in the parser.</p>
<pre><code class="language-solidity">error DanglingSource();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stackoverflow"><a class="header" href="#stackoverflow">StackOverflow</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<pre><code class="language-solidity">error StackOverflow();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsestate"><a class="header" href="#parsestate">ParseState</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<p>The parser is stateful. This struct keeps track of the entire state.</p>
<pre><code class="language-solidity">struct ParseState {
    uint256 activeSource;
    uint256 stackRHSOffset;
    uint256 stack0;
    uint256 stack1;
    uint256 sourcesBuilder;
    uint256 parenDepth;
    uint256 fsm;
    uint256 stackLHSIndex;
    uint256 stackNames;
    uint256 constantsBuilder;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libparsestate"><a class="header" href="#libparsestate">LibParseState</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<h2 id="functions-27"><a class="header" href="#functions-27">Functions</a></h2>
<h3 id="newstate-1"><a class="header" href="#newstate-1">newState</a></h3>
<pre><code class="language-solidity">function newState() internal pure returns (ParseState memory);
</code></pre>
<h3 id="pushstackname"><a class="header" href="#pushstackname">pushStackName</a></h3>
<pre><code class="language-solidity">function pushStackName(ParseState memory state, bytes32 word) internal pure;
</code></pre>
<h3 id="pushwordtosource"><a class="header" href="#pushwordtosource">pushWordToSource</a></h3>
<pre><code class="language-solidity">function pushWordToSource(ParseState memory state, bytes memory meta, bytes32 word) internal pure;
</code></pre>
<h3 id="newsource"><a class="header" href="#newsource">newSource</a></h3>
<pre><code class="language-solidity">function newSource(ParseState memory state) internal pure;
</code></pre>
<h3 id="buildsources"><a class="header" href="#buildsources">buildSources</a></h3>
<pre><code class="language-solidity">function buildSources(ParseState memory state) internal pure returns (bytes[] memory sources);
</code></pre>
<h3 id="buildconstants"><a class="header" href="#buildconstants">buildConstants</a></h3>
<pre><code class="language-solidity">function buildConstants(ParseState memory) internal pure returns (uint256[] memory);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libparse"><a class="header" href="#libparse">LibParse</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<h2 id="functions-28"><a class="header" href="#functions-28">Functions</a></h2>
<h3 id="stringtochar"><a class="header" href="#stringtochar">stringToChar</a></h3>
<pre><code class="language-solidity">function stringToChar(string memory s) external pure returns (uint256 char);
</code></pre>
<h3 id="parseerrorcontext"><a class="header" href="#parseerrorcontext">parseErrorContext</a></h3>
<pre><code class="language-solidity">function parseErrorContext(bytes memory data, uint256 cursor)
    internal
    pure
    returns (uint256 offset, string memory char);
</code></pre>
<h3 id="parseword"><a class="header" href="#parseword">parseWord</a></h3>
<pre><code class="language-solidity">function parseWord(uint256 cursor, uint256 mask) internal pure returns (uint256, bytes32);
</code></pre>
<h3 id="skipword"><a class="header" href="#skipword">skipWord</a></h3>
<pre><code class="language-solidity">function skipWord(uint256 cursor, uint256 mask) internal pure returns (uint256);
</code></pre>
<h3 id="parse-2"><a class="header" href="#parse-2">parse</a></h3>
<pre><code class="language-solidity">function parse(bytes memory data, bytes memory meta) internal pure returns (bytes[] memory sources, uint256[] memory);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-10"><a class="header" href="#constants-10">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParse.sol">Git Source</a></p>
<h3 id="cmask_tab"><a class="header" href="#cmask_tab">CMASK_TAB</a></h3>
<p><em>\t</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_TAB = 0x200;
</code></pre>
<h3 id="cmask_line_feed"><a class="header" href="#cmask_line_feed">CMASK_LINE_FEED</a></h3>
<p><em>\n</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_LINE_FEED = 0x400;
</code></pre>
<h3 id="cmask_carriage_return"><a class="header" href="#cmask_carriage_return">CMASK_CARRIAGE_RETURN</a></h3>
<p><em>\r</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_CARRIAGE_RETURN = 0x2000;
</code></pre>
<h3 id="cmask_space"><a class="header" href="#cmask_space">CMASK_SPACE</a></h3>
<p><em>space</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_SPACE = 0x0100000000;
</code></pre>
<h3 id="cmask_comma"><a class="header" href="#cmask_comma">CMASK_COMMA</a></h3>
<p><em>,</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_COMMA = 0x100000000000;
</code></pre>
<h3 id="cmask_eol"><a class="header" href="#cmask_eol">CMASK_EOL</a></h3>
<pre><code class="language-solidity">uint128 constant CMASK_EOL = CMASK_COMMA;
</code></pre>
<h3 id="cmask_dash"><a class="header" href="#cmask_dash">CMASK_DASH</a></h3>
<p><em>-</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_DASH = 0x200000000000;
</code></pre>
<h3 id="cmask_colon"><a class="header" href="#cmask_colon">CMASK_COLON</a></h3>
<p><em>:</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_COLON = 0x0400000000000000;
</code></pre>
<h3 id="cmask_lhs_rhs_delimiter"><a class="header" href="#cmask_lhs_rhs_delimiter">CMASK_LHS_RHS_DELIMITER</a></h3>
<p><em>LHS/RHS delimiter is :</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_LHS_RHS_DELIMITER = CMASK_COLON;
</code></pre>
<h3 id="cmask_semicolon"><a class="header" href="#cmask_semicolon">CMASK_SEMICOLON</a></h3>
<p><em>;</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_SEMICOLON = 0x800000000000000;
</code></pre>
<h3 id="cmask_eos"><a class="header" href="#cmask_eos">CMASK_EOS</a></h3>
<pre><code class="language-solidity">uint128 constant CMASK_EOS = CMASK_SEMICOLON;
</code></pre>
<h3 id="cmask_underscore"><a class="header" href="#cmask_underscore">CMASK_UNDERSCORE</a></h3>
<p><em>_</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_UNDERSCORE = 0x800000000000000000000000;
</code></pre>
<h3 id="cmask_left_paren"><a class="header" href="#cmask_left_paren">CMASK_LEFT_PAREN</a></h3>
<p><em>(</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_LEFT_PAREN = 0x10000000000;
</code></pre>
<h3 id="cmask_right_paren"><a class="header" href="#cmask_right_paren">CMASK_RIGHT_PAREN</a></h3>
<p><em>)</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_RIGHT_PAREN = 0x20000000000;
</code></pre>
<h3 id="cmask_lhs_stack_head"><a class="header" href="#cmask_lhs_stack_head">CMASK_LHS_STACK_HEAD</a></h3>
<p><em>lower alpha and underscore a-z _</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_LHS_STACK_HEAD = 0xffffffe800000000000000000000000;
</code></pre>
<h3 id="cmask_identifier_head"><a class="header" href="#cmask_identifier_head">CMASK_IDENTIFIER_HEAD</a></h3>
<p><em>lower alpha a-z</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_IDENTIFIER_HEAD = 0xffffffe000000000000000000000000;
</code></pre>
<h3 id="cmask_rhs_word_head"><a class="header" href="#cmask_rhs_word_head">CMASK_RHS_WORD_HEAD</a></h3>
<pre><code class="language-solidity">uint128 constant CMASK_RHS_WORD_HEAD = CMASK_IDENTIFIER_HEAD;
</code></pre>
<h3 id="cmask_identifier_tail"><a class="header" href="#cmask_identifier_tail">CMASK_IDENTIFIER_TAIL</a></h3>
<p><em>lower alphanumeric kebab a-z 0-9 -</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_IDENTIFIER_TAIL = 0xffffffe0000000003ff200000000000;
</code></pre>
<h3 id="cmask_lhs_stack_tail"><a class="header" href="#cmask_lhs_stack_tail">CMASK_LHS_STACK_TAIL</a></h3>
<pre><code class="language-solidity">uint128 constant CMASK_LHS_STACK_TAIL = CMASK_IDENTIFIER_TAIL;
</code></pre>
<h3 id="cmask_rhs_word_tail"><a class="header" href="#cmask_rhs_word_tail">CMASK_RHS_WORD_TAIL</a></h3>
<pre><code class="language-solidity">uint128 constant CMASK_RHS_WORD_TAIL = CMASK_IDENTIFIER_TAIL;
</code></pre>
<h3 id="cmask_not_identifier_tail"><a class="header" href="#cmask_not_identifier_tail">CMASK_NOT_IDENTIFIER_TAIL</a></h3>
<p><em>NOT lower alphanumeric kebab</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_NOT_IDENTIFIER_TAIL = 0xf0000001fffffffffc00dfffffffffff;
</code></pre>
<h3 id="cmask_whitespace"><a class="header" href="#cmask_whitespace">CMASK_WHITESPACE</a></h3>
<p><em>whitespace is \n \r \t space</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_WHITESPACE = 0x100002600;
</code></pre>
<h3 id="cmask_lhs_stack_delimiter"><a class="header" href="#cmask_lhs_stack_delimiter">CMASK_LHS_STACK_DELIMITER</a></h3>
<p><em>stack item delimiter is whitespace</em></p>
<pre><code class="language-solidity">uint128 constant CMASK_LHS_STACK_DELIMITER = CMASK_WHITESPACE;
</code></pre>
<h3 id="not_low_16_bit_mask"><a class="header" href="#not_low_16_bit_mask">NOT_LOW_16_BIT_MASK</a></h3>
<pre><code class="language-solidity">uint256 constant NOT_LOW_16_BIT_MASK = ~uint256(0xFFFF);
</code></pre>
<h3 id="active_source_mask"><a class="header" href="#active_source_mask">ACTIVE_SOURCE_MASK</a></h3>
<pre><code class="language-solidity">uint256 constant ACTIVE_SOURCE_MASK = NOT_LOW_16_BIT_MASK;
</code></pre>
<h3 id="fsm_lhs_mask"><a class="header" href="#fsm_lhs_mask">FSM_LHS_MASK</a></h3>
<pre><code class="language-solidity">uint256 constant FSM_LHS_MASK = 1;
</code></pre>
<h3 id="fsm_yang_mask"><a class="header" href="#fsm_yang_mask">FSM_YANG_MASK</a></h3>
<pre><code class="language-solidity">uint256 constant FSM_YANG_MASK = 1 &lt;&lt; 1;
</code></pre>
<h3 id="fsm_word_end_mask"><a class="header" href="#fsm_word_end_mask">FSM_WORD_END_MASK</a></h3>
<pre><code class="language-solidity">uint256 constant FSM_WORD_END_MASK = 1 &lt;&lt; 2;
</code></pre>
<h3 id="empty_active_source"><a class="header" href="#empty_active_source">EMPTY_ACTIVE_SOURCE</a></h3>
<pre><code class="language-solidity">uint256 constant EMPTY_ACTIVE_SOURCE = 0x20;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="duplicatefingerprint"><a class="header" href="#duplicatefingerprint">DuplicateFingerprint</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParseMeta.sol">Git Source</a></p>
<pre><code class="language-solidity">error DuplicateFingerprint();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libparsemeta"><a class="header" href="#libparsemeta">LibParseMeta</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParseMeta.sol">Git Source</a></p>
<h2 id="functions-29"><a class="header" href="#functions-29">Functions</a></h2>
<h3 id="wordbitmapped"><a class="header" href="#wordbitmapped">wordBitmapped</a></h3>
<pre><code class="language-solidity">function wordBitmapped(uint256 seed, bytes32 word) internal pure returns (uint256, uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>shifted</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>bitmapped</td></tr>
</tbody></table>
</div>
<h3 id="findbestexpander"><a class="header" href="#findbestexpander">findBestExpander</a></h3>
<pre><code class="language-solidity">function findBestExpander(bytes32[] memory words)
    internal
    pure
    returns (uint8 bestSeed, uint256 bestExpansion, bytes32[] memory remaining);
</code></pre>
<h3 id="buildmetaexpander"><a class="header" href="#buildmetaexpander">buildMetaExpander</a></h3>
<pre><code class="language-solidity">function buildMetaExpander(bytes32[] memory words, uint8 maxDepth) internal pure returns (bytes memory meta);
</code></pre>
<h3 id="lookupindexmetaexpander"><a class="header" href="#lookupindexmetaexpander">lookupIndexMetaExpander</a></h3>
<pre><code class="language-solidity">function lookupIndexMetaExpander(bytes memory meta, bytes32 word) internal pure returns (bool exists, uint256 index);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-11"><a class="header" href="#constants-11">Constants</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/parse/LibParseMeta.sol">Git Source</a></p>
<h3 id="fingerprint_mask"><a class="header" href="#fingerprint_mask">FINGERPRINT_MASK</a></h3>
<pre><code class="language-solidity">uint256 constant FINGERPRINT_MASK = 0xFFFFFFFF;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-16"><a class="header" href="#contents-16">Contents</a></h1>
<ul>
<li><a href="src/lib/state/LibInterpreterState.sol/struct.InterpreterState.html">InterpreterState</a></li>
<li><a href="src/lib/state/LibInterpreterState.sol/library.LibInterpreterState.html">LibInterpreterState</a></li>
<li><a href="src/lib/state/LibInterpreterStateDataContract.sol/library.LibInterpreterStateDataContract.html">LibInterpreterStateDataContract</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpreterstate"><a class="header" href="#interpreterstate">InterpreterState</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/state/LibInterpreterState.sol">Git Source</a></p>
<p>The standard in-memory representation of an interpreter that facilitates
decoupled coordination between opcodes. Opcodes MAY:</p>
<ul>
<li>push and pop values to the shared stack</li>
<li>read per-expression constants</li>
<li>write to the final state changes set within the fully qualified namespace</li>
<li>read per-eval context values</li>
<li>recursively evaluate any compiled source associated with the expression
As the interpreter defines the opcodes it is its responsibility to ensure the
opcodes are incapable of doing anything to undermine security or correctness.
For example, a hypothetical opcode could modify the current namespace from
the stack, but this would be a very bad idea as it would allow expressions
to hijack storage values associated with other callers, fundamentally
breaking the state sandbox model.
The iterpreter MAY skip any runtime integrity checks that can be reasonably
assumed to have been performed by a competent expression deployer, such as
guarding against stack underflow. A competent expression deployer MAY NOT
have deployed the currently evaluating expression, so the interpreter MUST
avoid state changes during evaluation, but MAY return garbage data if the
calling contract fails to leverage an appropriate expression deployer.</li>
</ul>
<pre><code class="language-solidity">struct InterpreterState {
    Pointer stackBottom;
    Pointer constantsBottom;
    MemoryKV stateKV;
    FullyQualifiedNamespace namespace;
    IInterpreterStoreV1 store;
    uint256[][] context;
    bytes[] compiledSources;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libinterpreterstate"><a class="header" href="#libinterpreterstate">LibInterpreterState</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/state/LibInterpreterState.sol">Git Source</a></p>
<h2 id="functions-30"><a class="header" href="#functions-30">Functions</a></h2>
<h3 id="fingerprint"><a class="header" href="#fingerprint">fingerprint</a></h3>
<p>Fingerprint the current state of the interpreter. This is used primarily
for testing purposes to ensure that the interpreter is (not) modified
during evaluation.</p>
<pre><code class="language-solidity">function fingerprint(InterpreterState memory state) internal pure returns (bytes32);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libinterpreterstatedatacontract"><a class="header" href="#libinterpreterstatedatacontract">LibInterpreterStateDataContract</a></h1>
<p><a href="https://github.com/rainprotocol/rain.interpreter/blob/4f5440388936d20366b4ae49ee1cae147c07bed8/src/lib/state/LibInterpreterStateDataContract.sol">Git Source</a></p>
<h2 id="functions-31"><a class="header" href="#functions-31">Functions</a></h2>
<h3 id="serializesize"><a class="header" href="#serializesize">serializeSize</a></h3>
<pre><code class="language-solidity">function serializeSize(bytes[] memory sources, uint256[] memory constants) internal pure returns (uint256 size);
</code></pre>
<h3 id="unsafeserialize"><a class="header" href="#unsafeserialize">unsafeSerialize</a></h3>
<p>Efficiently serializes enough information to build <code>InterpreterState</code>
without memory allocation or copying of data during deserialization.
This is achieved by mutating data in place for both serialization and
deserialization so it is much more gas efficient than abi encode/decode
but is NOT SAFE to use any of the inputs after the serialization.
Notably the index based opcodes in the <code>sources</code> will be compiled and
replaced by function pointer based opcodes in place.</p>
<pre><code class="language-solidity">function unsafeSerialize(
    Pointer cursor,
    bytes[] memory sources,
    uint256[] memory constants,
    uint256 stackLength,
    bytes memory opcodeFunctionPointers
) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cursor</code></td><td><code>Pointer</code></td><td>Pointer to memory to start the serialization.</td></tr>
<tr><td><code>sources</code></td><td><code>bytes[]</code></td><td>As per <code>IExpressionDeployerV1</code>.</td></tr>
<tr><td><code>constants</code></td><td><code>uint256[]</code></td><td>As per <code>IExpressionDeployerV1</code>.</td></tr>
<tr><td><code>stackLength</code></td><td><code>uint256</code></td><td>Stack length calculated by <code>IExpressionDeployerV1</code> that will be used to allocate memory for the stack upon deserialization.</td></tr>
<tr><td><code>opcodeFunctionPointers</code></td><td><code>bytes</code></td><td>As per <code>IInterpreterV1.functionPointers</code>, bytes to be compiled into the final <code>InterpreterState.compiledSources</code>.</td></tr>
</tbody></table>
</div>
<h3 id="unsafedeserialize"><a class="header" href="#unsafedeserialize">unsafeDeserialize</a></h3>
<p>Return trip from <code>serialize</code> but targets an <code>InterpreterState</code> NOT a
<code>ExpressionConfig</code>. Allows serialized bytes to be written directly into
contract code on the other side of an expression address, then loaded
directly into an eval-able memory layout. The only allocation required
is to initialise the stack for eval, there is no copying in memory from
the serialized data as the deserialization merely calculates Solidity
compatible pointers to positions in the raw serialized data. This is much
more gas efficient than an equivalent abi.decode call which would involve
more processing, copying and allocating.
Note that per-eval data such as namespace and context is NOT initialised
by the deserialization process and so will need to be handled by the
interpreter as part of <code>eval</code>.</p>
<pre><code class="language-solidity">function unsafeDeserialize(bytes memory serialized) internal pure returns (InterpreterState memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>serialized</code></td><td><code>bytes</code></td><td>Bytes previously serialized by <code>LibInterpreterState.serialize</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>InterpreterState</code></td><td>An eval-able interpreter state with initialized stack.</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="solidity.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
